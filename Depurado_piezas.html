<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Control de Calidad Corte</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <!-- SheetJS para exportar Excel -->
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 12px;
            overflow: hidden;
        }

        .container {
            max-width: 100%;
            height: calc(100vh - 24px);
            margin: 0 auto;
            display: flex;
            flex-direction: column;
        }

        header {
            text-align: center;
            color: white;
            margin-bottom: 12px;
            flex-shrink: 0;
        }

        h1 {
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 4px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 12px;
            opacity: 0.95;
            font-weight: 400;
        }

        .controls {
            background: white;
            border-radius: 8px;
            padding: 6px 10px;
            margin-bottom: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            flex-shrink: 0;
        }

        .controls-grid {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: nowrap;
            justify-content: space-between;
        }

        .filters-group {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: nowrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 4px;
            flex-shrink: 0;
        }

        .control-group label {
            font-weight: 600;
            color: #333;
            font-size: 10px;
            white-space: nowrap;
            padding: 2px 4px;
        }

        select {
            padding: 4px 8px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 11px;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        select:hover, select:focus {
            border-color: #2a5298;
            outline: none;
        }

        .btn {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 11px;
            white-space: nowrap;
        }

        .btn-primary {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(42, 82, 152, 0.4);
        }

        .main-content {
            flex: 1;
            display: grid;
            grid-template-columns: 2fr 1.32fr;
            grid-template-rows: auto minmax(350px, 1fr);
            gap: 10px;
            overflow: hidden;
        }

        .kpi-grid {
            grid-column: 1 / -1;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .kpi-card {
            background: white;
            border-radius: 8px;
            padding: 6px 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 0 0 calc(13.75% - 7px);
            min-width: 120px;
        }

        .kpi-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
            background: linear-gradient(180deg, #1e3c72 0%, #2a5298 100%);
        }

        .kpi-label {
            font-size: 11px;
            font-family: Calibri, sans-serif;
            color: #000;
            font-weight: 600;
            margin-bottom: 0;
            padding: 2px 4px;
            white-space: nowrap;
        }

        .kpi-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 6px;
        }

        .kpi-value {
            font-size: 16px;
            font-family: Calibri, sans-serif;
            font-weight: 700;
            color: #000;
            line-height: 1;
        }

        .kpi-subvalue {
            font-size: 13px;
            font-family: Calibri, sans-serif;
            color: #000;
            font-weight: 400;
            text-align: right;
            white-space: nowrap;
        }

        .kpi-percent {
            font-size: 12px;
            font-family: Calibri, sans-serif;
            color: #000;
            font-weight: 400;
            line-height: 1;
        }

        .chart-card {
            background: white;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Variante compacta para reducir espacio entre t√≠tulo y gr√°fico */
        .chart-card.compact {
            padding-top: 6px;
            padding-bottom: 6px;
        }

        .chart-card.compact .chart-title {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .chart-title {
            font-size: 12px;
            font-weight: 700;
            color: #333;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 2px solid #f0f0f0;
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chart-title-text {
            flex: 1;
        }

        .btn-acciones {
            padding: 4px 12px;
            font-size: 11px;
            font-weight: 600;
            background: #2a5298;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .btn-acciones:hover {
            background: #1e3c72;
        }

        .chart-container {
            position: relative;
            flex: 1;
            min-height: 0;
            max-height: 455px;
        }

        .pareto-section {
            grid-column: 1;
            grid-row: 2;
        }

        .right-section {
            grid-column: 2;
            grid-row: 2;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .top-ops {
            background: white;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        }

        .top-ops-title {
            font-size: 12px;
            font-weight: 700;
            color: #333;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 2px solid #f0f0f0;
            flex-shrink: 0;
        }

        .ops-list {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .op-item {
            padding: 6px 8px;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
        }

        .op-item:hover {
            background: #f8f9fa;
        }

        .op-info {
            flex: 1;
            min-width: 0;
        }

        .op-name {
            font-weight: 700;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .op-details {
            color: #666;
            font-size: 9px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .op-metric {
            font-weight: 700;
            font-size: 11px;
            margin-left: 8px;
            flex-shrink: 0;
        }

        .badge {
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 8px;
            font-weight: 600;
            text-transform: uppercase;
            margin-left: 6px;
            flex-shrink: 0;
        }

        .badge-danger {
            background: #fee;
            color: #c00;
        }

        .badge-warning {
            background: #ffeaa7;
            color: #856404;
        }

        .badge-success {
            background: #d4edda;
            color: #155724;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
        }

        .status-loading {
            background: #fff3cd;
            color: #856404;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
        }

        .hidden {
            display: none;
        }

        .ops-list::-webkit-scrollbar {
            width: 6px;
        }

        .ops-list::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .ops-list::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }

        .ops-list::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Modal detalle defecto */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.45);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            padding: 20px;
        }

        .modal-card {
            background: white;
            border-radius: 8px;
            width: 50%;
            max-width: 900px;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 6px 30px rgba(0,0,0,0.3);
        }

        /* Aumentar ancho del modal espec√≠fico de OP en ~40% (de 50% -> 70%) */
        #opModal .modal-card {
            width: 70% !important;
            max-width: 1200px;
            min-width: 700px;
        }

        .modal-header {
            padding: 10px 14px;
            border-bottom: 1px solid #eee;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgb(43,108,167);
            color: #fff;
        }

        .modal-title {
            font-weight: 700;
            font-family: 'Calibri, sans-serif';
        }

        .modal-body {
            padding: 10px 14px;
            overflow: auto;
            flex: 1;
        }

        .modal-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            table-layout: fixed; /* distribuir columnas a lo ancho */
        }

        .modal-table th, .modal-table td {
            padding: 6px 8px;
            border: 1px solid #f0f0f0;
            text-align: left;
            vertical-align: middle;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Encabezado de la tabla del modal */
        #defectModalHead th {
            background: rgb(155,194,230);
            color: #000;
            font-weight: 700;
        }

        /* Ajustar anchos de columnas espec√≠ficas en la tabla del modal de defectos */
        #defectModalTable th:nth-child(1),
        #defectModalTable td:nth-child(1) {
            width: 10%; /* CLIENTE */
        }

        #defectModalTable th:nth-child(2),
        #defectModalTable td:nth-child(2) {
            width: 15%; /* OP_TELA-PTDA */
        }

        #defectModalTable th:nth-child(3),
        #defectModalTable td:nth-child(3) {
            width: 8%; /* OP */
        }

        #defectModalTable th:nth-child(4),
        #defectModalTable td:nth-child(4) {
            width: 50%; /* COLOR - m√°s ancha */
        }

        #defectModalTable th:nth-child(5),
        #defectModalTable td:nth-child(5) {
            width: 17%; /* Columna de cantidad de defectos */
        }

        /* Estilos espec√≠ficos para la tabla de resumen OP: permitir que la tabla crezca
           horizontalmente y que los encabezados muestren el texto completo (scroll horizontal) */
        #opResumenTable {
            table-layout: auto !important;
            width: max-content !important;
            min-width: 100%;
        }

        #opResumenTable th {
            background: rgb(155,194,230);
            color: #000;
            font-weight: 700;
            white-space: nowrap;
            font-size: 12px;
        }

        #opResumenTable td {
            white-space: nowrap;
            font-size: 12px;
        }

        /* Ajustes para que la tabla de resumen OP quepa en el modal, con scroll vertical
           si hay muchas filas y encabezados fijos. Mantiene la tabla con layout normal
           para asegurar alineaci√≥n correcta entre th y td. */
        .op-table-wrapper {
            overflow: auto;
            max-height: calc(70vh - 120px); /* espacio para modal header y controles */
            width: 100%;
        }

        /* La tabla ocupa el ancho disponible del modal; si hay muchas columnas, el wrapper
           mostrar√° scroll horizontal. */
        #opResumenTable {
            table-layout: auto !important;
            width: 100% !important;
            min-width: 0;
            border-collapse: collapse;
        }

        /* Cabeceras fijas en la parte superior del wrapper */
        #opResumenTable thead th {
            position: sticky;
            top: 0;
            z-index: 5;
            background: rgb(155,194,230);
        }

        #opResumenTable th, #opResumenTable td {
            white-space: nowrap;
            font-size: 12px;
            padding: 6px;
            border-bottom: 1px solid #f5f5f5;
        }

        /* Totals bar under table */
        .op-resumen-totals {
            margin-top: 8px;
            background: #f1f5f9;
            padding: 8px 10px;
            border-radius: 6px;
            font-weight: 700;
            display: flex;
            justify-content: center;
            gap: 12px;
            color: #1e3c72;
            font-size: 14px;
            line-height: 1.2;
        }

        .modal-actions {
            padding: 8px 12px;
            border-top: 1px solid #eee;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .btn-close {
            background: #e0e0e0;
            border: none;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }

        /* Context Menu para seleccionar Detalle o Tendencia */
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 10000;
            display: none;
            min-width: 160px;
            padding: 4px 0;
        }

        .context-menu-item {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 13px;
            color: #333;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:hover {
            background: #f0f0f0;
        }

        .context-menu-item:first-child {
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
        }

        .context-menu-item:last-child {
            border-bottom-left-radius: 8px;
            border-bottom-right-radius: 8px;
        }

        /* Modal de Tendencia */
        #trendModal .modal-card {
            width: 80%;
            max-width: 1400px;
        }

        .trend-chart-container {
            height: 500px;
            padding: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üéØ Reporte depurado en corte</h1>
        </header>

        <div class="controls">
            <div class="controls-grid">
                <div class="filters-group">
                    <div class="control-group">
                        <label>A√±o:</label>
                        <select id="yearSelect" onchange="applyFilters()">
                            <option value="">Todos</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Periodo:</label>
                        <select id="periodTypeSelect" onchange="togglePeriodFilter()">
                            <option value="week">Por Semana</option>
                            <option value="month">Por Mes</option>
                        </select>
                    </div>
                    <div class="control-group" id="weekFilterGroup">
                        <label>Semana:</label>
                        <select id="weekSelect" onchange="applyFilters()">
                            <option value="">Todas</option>
                        </select>
                    </div>
                    <div class="control-group" id="monthFilterGroup" style="display: none;">
                        <label>Mes:</label>
                        <select id="monthSelect" onchange="applyFilters()">
                            <option value="">Todos</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Cliente:</label>
                        <select id="clienteSelect" onchange="applyFilters()">
                            <option value="">Todos</option>
                        </select>
                    </div>
                </div>
                <div style="display:flex;align-items:center;gap:8px;">
                    <button id="telaButton" class="btn" style="padding:6px 10px;font-size:12px;background:#ffffff;border:1px solid #2a5298;color:#2a5298;font-weight:700;">TELA</button>
                    <button id="opButton" class="btn-primary" style="padding:6px 10px;font-size:12px;">OP</button>
                    <span id="loadingStatus" class="status-badge status-loading">Cargando...</span>
                </div>
            </div>
        </div>

        <!-- Panel de Diagn√≥stico (oculto por defecto) -->
        <div id="diagnosticPanel" style="display:none;background:#fff3cd;border-radius:8px;padding:10px;margin-bottom:8px;box-shadow:0 2px 8px rgba(0,0,0,0.2);font-size:11px;font-family:monospace;">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
                <strong style="color:#856404;">üîç Panel de Diagn√≥stico</strong>
                <button onclick="toggleDiagnosticPanel()" style="padding:4px 8px;font-size:10px;border:1px solid #856404;background:transparent;cursor:pointer;border-radius:4px;">Ocultar</button>
            </div>
            <div id="diagnosticContent" style="color:#856404;line-height:1.6;">
                Cargando diagn√≥stico...
            </div>
        </div>

        <div class="main-content">
            <div id="kpiSection" class="kpi-grid">
                <!-- KPI cards -->
            </div>

            <div class="chart-card pareto-section">
                <h3 class="chart-title">
                    <span class="chart-title-text">üìä Pareto de Defectos (Piezas Depuradas)</span>
                    <button id="btnAcciones" class="btn-acciones">Acciones</button>
                </h3>
                <div class="chart-container">
                    <canvas id="paretoChart"></canvas>
                </div>
            </div>

            <!-- Modal para b√∫squeda/Resumen por OP -->
            <div id="opModal" class="modal-overlay" role="dialog" aria-modal="true" style="display:none;">
                <div class="modal-card" role="document" style="max-width:1000px;">
                    <div class="modal-header">
                        <div class="modal-title">Resumen por OP</div>
                        <button id="opModalClose" class="btn-close" aria-label="Cerrar">Cerrar</button>
                    </div>
                    <div class="modal-body">
                        <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;">
                                <div style="flex:0 0 auto;">
                                <label style="font-weight:600;display:block;margin-bottom:4px;">OP (buscar)</label>
                                <input id="opSearchInput" type="text" placeholder="Escribe OP (m√°x 6 d√≠g.)" maxlength="6" pattern="\d*" inputmode="numeric" style="width:120px;max-width:120px;padding:6px;font-size:13px;" />
                            </div>
                            <div style="width:260px;">
                                <label style="font-weight:600;display:block;margin-bottom:4px;">COLOR (filtrar)</label>
                                <select id="colorSelect" style="width:100%;padding:6px;font-size:13px;"><option value="">(todos)</option></select>
                            </div>
                            <div style="display:flex;flex-direction:column;gap:6px;align-items:flex-end;">
                                <div style="display:flex;gap:8px;">
                                    <button id="opResumenBtn" class="btn-primary" style="padding:8px 12px;">Resumen</button>
                                    <button id="opExportBtn" class="btn" style="padding:8px 12px;background:#fff;border:1px solid #2a5298;color:#2a5298;">Excel</button>
                                </div>
                            </div>
                        </div>

                        <div class="op-table-wrapper" style="border-top:1px solid:#eee;padding-top:8px;">
                            <table id="opResumenTable" class="modal-table" style="border-collapse:collapse;font-family:Calibri, sans-serif;font-size:11px;">
                                <thead id="opResumenHead"><tr></tr></thead>
                                <tbody id="opResumenBody"></tbody>
                            </table>
                        </div>
                        <div id="opResumenTotals" class="op-resumen-totals" role="status" aria-live="polite" style="display:none;">
                            <div id="opResumenTotalsText"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Modal para resumen por TELA -->
            <div id="telaModal" class="modal-overlay" role="dialog" aria-modal="true" style="display:none;">
                <div class="modal-card" role="document" style="width:62.5%; max-width:1375px; min-width:800px;">
                    <div class="modal-header">
                        <div class="modal-title">Resumen por TELA</div>
                        <button id="telaModalClose" class="btn-close" aria-label="Cerrar">Cerrar</button>
                    </div>
                    <div class="modal-body">
                        <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;flex-wrap:wrap;">
                            <div style="display:flex;gap:8px;align-items:center;">
                                <div style="display:flex;flex-direction:column;">
                                    <label style="font-weight:600;display:block;margin-bottom:4px;">A√±o:</label>
                                    <select id="telaYearSelect" style="padding:6px;font-size:13px;"></select>
                                </div>
                                <div style="display:flex;flex-direction:column;">
                                    <label style="font-weight:600;display:block;margin-bottom:4px;">Periodo:</label>
                                    <select id="telaPeriodTypeSelect" style="padding:6px;font-size:13px;"><option value="week">Por Semana</option><option value="month">Por Mes</option></select>
                                </div>
                                <div id="telaWeekGroup" style="display:flex;flex-direction:column;">
                                    <label style="font-weight:600;display:block;margin-bottom:4px;">Semana:</label>
                                    <select id="telaWeekSelect" style="padding:6px;font-size:13px;"></select>
                                </div>
                                <div id="telaMonthGroup" style="display:none;flex-direction:column;">
                                    <label style="font-weight:600;display:block;margin-bottom:4px;">Mes:</label>
                                    <select id="telaMonthSelect" style="padding:6px;font-size:13px;"></select>
                                </div>
                                <div style="display:flex;flex-direction:column;min-width:220px;">
                                    <label style="font-weight:600;display:block;margin-bottom:4px;">Cliente:</label>
                                    <select id="telaClienteSelect" style="padding:6px;font-size:13px;"></select>
                                </div>
                            </div>
                            <div style="margin-left:auto;display:flex;gap:8px;">
                                <button id="telaRefreshBtn" class="btn-primary" style="padding:8px 12px;">Actualizar</button>
                                <button id="telaExportBtn" class="btn" style="padding:8px 12px;background:#fff;border:1px solid #2a5298;color:#2a5298;" disabled>Excel</button>
                            </div>
                        </div>

                        <div class="op-table-wrapper" style="border-top:1px solid:#eee;padding-top:8px;">
                            <table id="telaResumenTable" class="modal-table" style="border-collapse:collapse;font-family:Calibri, sans-serif;font-size:12px;">
                                <thead id="telaResumenHead"><tr></tr></thead>
                                <tbody id="telaResumenBody"></tbody>
                            </table>
                        </div>
                        <div id="telaResumenTotals" class="op-resumen-totals" role="status" aria-live="polite" style="display:none;">
                            <div id="telaResumenTotalsText"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Modal para detalle de defecto al clicar barra -->
            <div id="defectModal" class="modal-overlay" role="dialog" aria-modal="true">
                <div class="modal-card" role="document">
                    <div class="modal-header">
                        <div class="modal-title" id="defectModalTitle">Detalle</div>
                        <button id="defectModalClose" class="btn-close" aria-label="Cerrar">Cerrar</button>
                    </div>
                    <div class="modal-body">
                        <div style="overflow:auto;">
                            <table id="defectModalTable" class="modal-table">
                                <thead>
                                    <tr id="defectModalHead">
                                        <!-- Headers din√°micos -->
                                    </tr>
                                </thead>
                                <tbody id="defectModalBody">
                                    <!-- Filas din√°micas -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                
                </div>
            </div>

            <!-- Modal para Tendencia del defecto -->
            <div id="trendModal" class="modal-overlay" role="dialog" aria-modal="true" style="display:none;">
                <div class="modal-card" role="document">
                            <div class="modal-header">
                                <div class="modal-title" id="trendModalTitle">Tendencia del Defecto</div>
                                <div style="display:flex;gap:8px;align-items:center;">
                                    <button id="trendModalAccion" class="btn-acciones" style="background:#1e7a4d;">Accion</button>
                                    <button id="trendModalClose" class="btn-close" aria-label="Cerrar">Cerrar</button>
                                </div>
                            </div>
                    <div class="modal-body">
                        <div class="trend-chart-container">
                            <canvas id="trendChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Context Menu para elegir entre Detalle y Tendencia -->
            <div id="defectContextMenu" class="context-menu">
                <div class="context-menu-item" id="contextMenuDetail">
                    üìã Detallar
                </div>
                <div class="context-menu-item" id="contextMenuTrend">
                    üìà Tendencia
                </div>
            </div>

            <!-- Modal para tabla de Acciones -->
            <div id="accionesModal" class="modal-overlay" role="dialog" aria-modal="true" style="display:none;">
                <div class="modal-card" role="document" style="max-width:95%;width:95%;">
                    <div class="modal-header">
                        <div class="modal-title">üìã Tabla de Acciones</div>
                        <button id="accionesModalClose" class="btn-close" aria-label="Cerrar">Cerrar</button>
                    </div>
                    <div class="modal-body">
                        <div style="overflow:auto;max-height:600px;">
                            <table id="accionesTable" class="modal-table" style="border-collapse:collapse;font-family:Calibri, sans-serif;font-size:12px;width:100%;">
                                <thead id="accionesTableHead" style="position:sticky;top:0;z-index:10;">
                                    <tr></tr>
                                </thead>
                                <tbody id="accionesTableBody">
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Modal para detalle de TELA al hacer click -->
            <div id="telaDetailModal" class="modal-overlay" role="dialog" aria-modal="true" style="display:none;">
                <div class="modal-card" role="document" style="max-width:95%;width:95%;">
                    <div class="modal-header">
                        <div class="modal-title" id="telaDetailModalTitle">Detalle de TELA</div>
                        <button id="telaDetailModalClose" class="btn-close" aria-label="Cerrar">Cerrar</button>
                    </div>
                    <div class="modal-body">
                        <div style="overflow:auto;max-height:600px;position:relative;">
                            <table id="telaDetailTable" class="modal-table" style="border-collapse:collapse;font-family:Calibri, sans-serif;font-size:12px;width:100%;">
                                <thead id="telaDetailHead" style="position:sticky;top:0;z-index:10;">
                                    <tr></tr>
                                </thead>
                                <tbody id="telaDetailBody">
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <div class="right-section">
                <div class="chart-card compact" style="flex: 1;">
                    <h3 class="chart-title">Pds Cortadas/Revisadas Vs No recuperados</h3>
                    <div class="chart-container">
                        <canvas id="factoryChart"></canvas>
                    </div>
                </div>

                <div class="top-ops" style="flex: 1;">
                    <div class="two-tables" id="topOpsList" style="display:flex;gap:8px;height:100%;">
                        <div class="table-card" style="flex:0.8;overflow:auto;">
                            <table id="clientsTable" class="compact-table" style="width:100%;border-collapse:collapse;font-family:Calibri, sans-serif;font-size:14px;">
                                <thead>
                                    <tr>
                                        <th style="text-align:left;padding:6px;border-bottom:1px solid #ddd;background-color:rgb(43,108,167);color:#fff;position:sticky;top:0;z-index:3;">CLIENTE</th>
                                        <th style="text-align:right;padding:6px;border-bottom:1px solid #ddd;background-color:rgb(43,108,167);color:#fff;position:sticky;top:0;z-index:3;">Revis.</th>
                                        <th style="text-align:right;padding:6px;border-bottom:1px solid #ddd;background-color:rgb(43,108,167);color:#fff;position:sticky;top:0;z-index:3;">Dep.</th>
                                        <th style="text-align:right;padding:6px;border-bottom:1px solid #ddd;background-color:rgb(43,108,167);color:#fff;position:sticky;top:0;z-index:3;">%Dep.</th>
                                    </tr>
                                </thead>
                                <tbody>
                                </tbody>
                            </table>
                        </div>
                        <div class="table-card" style="flex:1.2;overflow:auto;">
                            <table id="opsTable" class="compact-table" style="width:100%;border-collapse:collapse;font-family:Calibri, sans-serif;font-size:14px;">
                                <thead>
                                    <tr>
                                        <th style="text-align:left;padding:6px;border-bottom:1px solid #ddd;background-color:rgb(43,108,167);color:#fff;position:sticky;top:0;z-index:3;">OP</th>
                                        <th style="text-align:left;padding:6px;border-bottom:1px solid #ddd;background-color:rgb(43,108,167);color:#fff;position:sticky;top:0;z-index:3;">COLOR</th>
                                        <th style="text-align:right;padding:6px;border-bottom:1px solid #ddd;background-color:rgb(43,108,167);color:#fff;position:sticky;top:0;z-index:3;">Revis.</th>
                                        <th style="text-align:right;padding:6px;border-bottom:1px solid #ddd;background-color:rgb(43,108,167);color:#fff;position:sticky;top:0;z-index:3;">Dep.</th>
                                        <th style="text-align:right;padding:6px;border-bottom:1px solid #ddd;background-color:rgb(43,108,167);color:#fff;position:sticky;top:0;z-index:3;">%Dep.</th>
                                    </tr>
                                </thead>
                                <tbody>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Registrar el plugin de datalabels
        Chart.register(ChartDataLabels);
        
        const SHEET_ID = '1sFkWMxxLM7DO4erVoQtvHyrUk8ynJ4E1PVf6dIwnuBg';
        const BASE_SHEET = 'base';
        const PROD_CORTE_SHEET = 'prod_corte';
        const ACCIONES_SHEET = 'acciones';

        let baseData = [];
        let prodCorteData = [];
        let accionesData = [];
        let defectColumns = [];
        let currentFilters = { year: '', periodType: 'week', month: '', week: '', cliente: '' };
        let paretoChart = null;
        let factoryChart = null;
        // Preferencia de orden de d√≠a/mes para parseo: 'DMY' o 'MDY' o null para autodetectar
        let dateOrderPreference = null;
        // Estado del √∫ltimo resumen mostrado en modal (para exportar)
        let lastResumenRows = [];
        let lastResumenDefects = [];
        let diagnosticData = {};

        function toggleDiagnosticPanel() {
            const panel = document.getElementById('diagnosticPanel');
            if (panel.style.display === 'none') {
                panel.style.display = '';
                updateDiagnosticPanel();
            } else {
                panel.style.display = 'none';
            }
        }

        function updateDiagnosticPanel() {
            const content = document.getElementById('diagnosticContent');
            if (!content) return;
            
            const html = `
                <div><strong>Datos cargados:</strong></div>
                <div>‚Ä¢ Base: ${baseData ? baseData.length : 0} filas</div>
                <div>‚Ä¢ Prod_Corte: ${prodCorteData ? prodCorteData.length : 0} filas</div>
                <div>‚Ä¢ Defectos detectados: ${defectColumns ? defectColumns.length : 0} columnas</div>
                ${diagnosticData.datePreference ? `<div>‚Ä¢ Formato fecha: <strong>${diagnosticData.datePreference}</strong></div>` : ''}
                ${diagnosticData.yearStats ? `<div>‚Ä¢ A√±os detectados: ${diagnosticData.yearStats}</div>` : ''}
                ${diagnosticData.parsedCount !== undefined ? `<div>‚Ä¢ Fechas parseadas: ${diagnosticData.parsedCount} de ${baseData ? baseData.length : 0}</div>` : ''}
                ${diagnosticData.badDateSamples ? `<div style="color:#d9534f;">‚ö† Fechas no parseadas (ejemplos): ${diagnosticData.badDateSamples}</div>` : ''}
                <div style="margin-top:8px;"><strong>Filtros activos:</strong></div>
                <div>‚Ä¢ A√±o: ${currentFilters.year || '(todos)'}</div>
                <div>‚Ä¢ Periodo: ${currentFilters.periodType === 'week' ? 'Semana' : 'Mes'}</div>
                ${currentFilters.periodType === 'week' ? `<div>‚Ä¢ Semana: ${currentFilters.week || '(todas)'}</div>` : ''}
                ${currentFilters.periodType === 'month' ? `<div>‚Ä¢ Mes: ${currentFilters.month || '(todos)'}</div>` : ''}
                <div>‚Ä¢ Cliente: ${currentFilters.cliente || '(todos)'}</div>
                ${diagnosticData.filteredCount !== undefined ? `<div style="margin-top:4px;"><strong>Filas filtradas: ${diagnosticData.filteredCount}</strong></div>` : ''}
            `;
            content.innerHTML = html;
        }

        function gvizToObjects(resp) {
            if (!resp || !resp.table) return [];
            const cols = (resp.table.cols || []).map(c => String(c.label || c.id || '').trim());
            return (resp.table.rows || []).map(r => {
                const o = {};
                cols.forEach((h, i) => {
                    const cell = r.c && r.c[i] ? r.c[i] : null;
                    o[h] = cell && (cell.v !== null && cell.v !== undefined) ? cell.v : '';
                });
                return o;
            });
        }

        function loadSheetJSONP(sheetId, sheetName) {
            return new Promise((resolve, reject) => {
                const cbName = 'GVIZ_CB_' + Math.random().toString(36).slice(2);
                let script = document.createElement('script');
                const timer = setTimeout(() => {
                    cleanup();
                    reject(new Error(`Timeout al cargar "${sheetName}"`));
                }, 15000);

                function cleanup() {
                    clearTimeout(timer);
                    delete window[cbName];
                    if (script && script.parentNode) {
                        script.parentNode.removeChild(script);
                    }
                }

                window[cbName] = function(resp) {
                    cleanup();
                    try {
                        resolve(gvizToObjects(resp));
                    } catch (e) {
                        reject(new Error('Error al procesar datos: ' + e.message));
                    }
                };

                script.onerror = () => {
                    cleanup();
                    reject(new Error(`No se pudo cargar "${sheetName}"`));
                };

                const base = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq`;
                const url = `${base}?sheet=${encodeURIComponent(sheetName)}&headers=1&tq=${encodeURIComponent('select *')}&tqx=out:json;responseHandler:${cbName}&nocache=${Date.now()}`;
                
                script.src = url;
                document.head.appendChild(script);
            });
        }

        function toNum(val) {
            if (val === '' || val === null || val === undefined) return 0;
            const num = parseFloat(val);
            return isNaN(num) ? 0 : num;
        }

        function formatNum(num) {
            return num.toLocaleString('es-PE', { maximumFractionDigits: 0 });
        }

        function formatPercent(num, decimals = 2) {
            return num.toLocaleString('es-PE', { minimumFractionDigits: decimals, maximumFractionDigits: decimals }) + '%';
        }

        function updateStatus(text, type = 'loading') {
            const badge = document.getElementById('loadingStatus');
            badge.className = `status-badge status-${type}`;
            badge.textContent = text;
        }

        function detectDefectColumns(data) {
            if (!data || data.length === 0) return [];
            const allCols = Object.keys(data[0]);
            
            // Columnas conocidas que NO son defectos (incluye variaciones con espacios, puntos, etc)
            const knownCols = ['SEM', 'SEMANA', 'CLIENTE', 'OP', 'TENDIDO', 'FECHA', 'FECHA CORTE', 'FECHA_COR',
                             'CODIGO', 'TELA', 'PARTIDA', 'DESCRIPCION', 'COLOR', 'OP_TELA', 'PTDA',
                             'CANT.', 'CANT', 'CORTADA', 'DEPURADO', 'RECUPERADOS', 'RECUPERADO', 
                             'REAL', 'NO RECUPERADO', 'PERDIDA', 'NETA', 'FACTORY', '_year', '_month', '_week'];
            
            return allCols.filter(col => {
                const upperCol = col.toUpperCase().trim();
                // Excluir columnas vac√≠as o que contengan alguna palabra conocida
                if (col.trim() === '') return false;
                return !knownCols.some(known => upperCol.includes(known));
            });
        }

        function populateFilters() {
            // Detectar preferencia de formato de FECHA CORTE (MDY vs DMY) antes de parsear
            try {
                dateOrderPreference = guessDateOrderFromSamples(baseData, 'FECHA CORTE');
                console.log('‚úì Preferencia de formato de fecha detectada:', dateOrderPreference);
                // Mostrar algunas muestras de FECHA CORTE para depuraci√≥n
                const samples = baseData.slice(0, 5).map(r => r['FECHA CORTE']).filter(f => f);
                console.log('Muestras de FECHA CORTE (primeras 5):', samples);
            } catch (e) {
                console.warn('No se pudo detectar preferencia de formato de fecha, usando heur√≠stica por defecto');
                dateOrderPreference = null;
            }

            // Procesar fechas y extraer a√±o, mes, semana usando parseo flexible
            const badDates = [];
            baseData.forEach(row => {
                const fechaCorte = row['FECHA CORTE'];
                if (fechaCorte) {
                    const date = parseDateFlexible(fechaCorte);
                    if (date) {
                        row._year = date.getFullYear();
                        row._month = date.getMonth() + 1; // 1-12
                        row._week = getWeekNumber(date);
                    } else {
                        badDates.push(fechaCorte);
                    }
                }
            });

            // A√±os: combinar de base (FECHA CORTE procesada) y prod_corte (columna A√ëO)
            const yearsFromBase = baseData.map(r => r._year).filter(y => y);
            const yearsFromProdCorte = prodCorteData.map(r => toNum(r['A√ëO']) || toNum(r.A√ëO)).filter(y => y);
            const years = [...new Set([...yearsFromBase, ...yearsFromProdCorte])].sort((a, b) => a - b);
            const yearSelect = document.getElementById('yearSelect');
            years.forEach(year => {
                const opt = document.createElement('option');
                opt.value = year;
                opt.textContent = year;
                yearSelect.appendChild(opt);
            });

            // Meses: combinar de base (FECHA CORTE procesada) y prod_corte (columna MES)
            const monthsFromBase = baseData.map(r => r._month).filter(m => m);
            const monthsFromProdCorte = prodCorteData.map(r => toNum(r.MES) || toNum(r['MES'])).filter(m => m);
            const months = [...new Set([...monthsFromBase, ...monthsFromProdCorte])].sort((a, b) => a - b);
            const monthSelect = document.getElementById('monthSelect');
            const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
            months.forEach(month => {
                const opt = document.createElement('option');
                opt.value = month;
                opt.textContent = monthNames[month - 1];
                monthSelect.appendChild(opt);
            });

            // Semanas: combinar de base (SEM) y prod_corte (SEM)
            const weeksFromBase = baseData.map(r => toNum(r.SEM)).filter(w => w);
            const weeksFromProdCorte = prodCorteData.map(r => toNum(r.SEM)).filter(w => w);
            const weeks = [...new Set([...weeksFromBase, ...weeksFromProdCorte])].sort((a, b) => a - b);
            const weekSelect = document.getElementById('weekSelect');
            weeks.forEach(week => {
                const opt = document.createElement('option');
                opt.value = week;
                opt.textContent = `Semana ${week}`;
                weekSelect.appendChild(opt);
            });

            // Clientes
            const clientes = [...new Set(baseData.map(r => r.CLIENTE).filter(c => c))].sort();
            const clienteSelect = document.getElementById('clienteSelect');
            clientes.forEach(cliente => {
                const opt = document.createElement('option');
                opt.value = cliente;
                opt.textContent = cliente;
                clienteSelect.appendChild(opt);
            });

            // Logs para depuraci√≥n: a√±os detectados y ejemplos de FECHA CORTE que no se parsearon
            const yearsWithCount = baseData.reduce((acc, r) => {
                if (r._year) acc[r._year] = (acc[r._year] || 0) + 1;
                return acc;
            }, {});
            console.log('‚úì A√±os detectados en FECHA CORTE:', years);
            console.log('Distribuci√≥n de filas por a√±o:', yearsWithCount);
            console.log(`Total filas procesadas: ${baseData.length}, con fecha v√°lida: ${baseData.filter(r => r._year).length}`);
            
            // Guardar info de diagn√≥stico
            diagnosticData.datePreference = dateOrderPreference;
            diagnosticData.yearStats = years.join(', ');
            diagnosticData.parsedCount = baseData.filter(r => r._year).length;
            
            if (badDates.length > 0) {
                const uniq = [...new Set(badDates)].slice(0, 20);
                console.warn(`‚ö†Ô∏è ${badDates.length} valores de FECHA CORTE no se pudieron parsear (ejemplos):`, uniq);
                diagnosticData.badDateSamples = uniq.slice(0, 5).join(', ');
            } else {
                diagnosticData.badDateSamples = null;
            }
        }

        function getWeekNumber(date) {
            const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
            const dayNum = d.getUTCDay() || 7;
            d.setUTCDate(d.getUTCDate() + 4 - dayNum);
            const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
        }

        function togglePeriodFilter() {
            const periodType = document.getElementById('periodTypeSelect').value;
            const weekGroup = document.getElementById('weekFilterGroup');
            const monthGroup = document.getElementById('monthFilterGroup');
            
            if (periodType === 'week') {
                weekGroup.style.display = '';
                monthGroup.style.display = 'none';
                document.getElementById('monthSelect').value = '';
            } else {
                weekGroup.style.display = 'none';
                monthGroup.style.display = '';
                document.getElementById('weekSelect').value = '';
            }
            
            applyFilters();
        }

        function parseDateFlexible(input) {
            if (!input && input !== 0) return null;
            // If already a Date
            if (input instanceof Date) return isNaN(input) ? null : input;
            // If Google returned an object-like date (sometimes GViz returns {v: Date})
            if (typeof input === 'object' && input.v instanceof Date) return isNaN(input.v) ? null : input.v;
            // If Google Sheets date object with formatted value
            if (typeof input === 'object' && input.f) {
                const formatted = String(input.f).trim();
                const parsed = parseDateFlexible(formatted);
                if (parsed) return parsed;
            }
            // If numeric (milliseconds since epoch or Excel serial date)
            if (typeof input === 'number') {
                // Excel serial dates are typically < 100000
                if (input > 0 && input < 100000) {
                    // Excel serial date (days since 1900-01-01)
                    const excelEpoch = new Date(1899, 11, 30); // Dec 30, 1899
                    const d = new Date(excelEpoch.getTime() + input * 86400000);
                    if (!isNaN(d)) return d;
                } else {
                    // Milliseconds since epoch
                    const d = new Date(input);
                    if (!isNaN(d)) return d;
                }
            }

            const s = String(input).trim();
            if (!s) return null;
            
            // Google Sheets sometimes returns dates as strings like "Date(2025,0,3)"
            const dateMatch = s.match(/^Date\((\d+),(\d+),(\d+)\)$/);
            if (dateMatch) {
                const year = parseInt(dateMatch[1], 10);
                const month = parseInt(dateMatch[2], 10); // already 0-indexed in JS
                const day = parseInt(dateMatch[3], 10);
                const d = new Date(year, month, day);
                if (!isNaN(d)) return d;
            }
            
            // Try native parse (ISO / RFC)
            let d = new Date(s);
            if (!isNaN(d) && d.getFullYear() > 1900) return d;

            // Try DD/MM/YYYY or D/M/YYYY
            const m1 = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
            if (m1) {
                const p1 = parseInt(m1[1], 10);
                const p2 = parseInt(m1[2], 10);
                const year = parseInt(m1[3], 10);

                // If a global preference was detected, use it. Otherwise try to be flexible:
                // - If one of the parts >12, that part must be day.
                // - If both <=12 and preference exists, use it.
                // - Fallback: try MDY first (common for Google Sheets), then DMY.
                function tryDMY() { return new Date(year, p2 - 1, p1); }
                function tryMDY() { return new Date(year, p1 - 1, p2); }

                // If one part > 12, determine unique mapping
                if (p1 > 12 && p2 <= 12) {
                    d = tryDMY(); if (!isNaN(d)) return d;
                }
                if (p2 > 12 && p1 <= 12) {
                    d = tryMDY(); if (!isNaN(d)) return d;
                }

                if (dateOrderPreference === 'DMY') {
                    d = tryDMY(); if (!isNaN(d)) return d;
                } else if (dateOrderPreference === 'MDY') {
                    d = tryMDY(); if (!isNaN(d)) return d;
                } else {
                    // No preference: try MDY first (covers MM/DD/YYYY), then DMY
                    d = tryMDY(); if (!isNaN(d)) return d;
                    d = tryDMY(); if (!isNaN(d)) return d;
                }
            }

            // Try YYYY-MM-DD or YYYY/MM/DD
            const m2 = s.match(/^(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})/);
            if (m2) {
                const year = parseInt(m2[1], 10);
                const month = parseInt(m2[2], 10) - 1;
                const day = parseInt(m2[3], 10);
                d = new Date(year, month, day);
                if (!isNaN(d)) return d;
            }

            // Try DD-MMM-YY or DD-MMM-YYYY with month names (Spanish/English)
            const m3 = s.match(/^(\d{1,2})[\-\s]([A-Za-z√Ä-√ø\.]{3,})[\-\s](\d{2,4})$/);
            if (m3) {
                const day = parseInt(m3[1], 10);
                let mon = m3[2].replace('.', '').toLowerCase();
                const yy = m3[3];
                const monthsMap = {
                    ene:0, feb:1, mar:2, abr:3, may:4, jun:5, jul:6, ago:7, sep:8, set:8, oct:9, nov:10, dic:11,
                    jan:0, feb:1, mar:2, apr:3, may:4, jun:5, jul:6, aug:7, sep:8, oct:9, nov:10, dec:11
                };
                const key3 = mon.slice(0,3);
                let monthIdx = monthsMap[key3];
                if (monthIdx === undefined) {
                    for (const k in monthsMap) {
                        if (k === mon) { monthIdx = monthsMap[k]; break; }
                    }
                }
                if (monthIdx !== undefined) {
                    let year = parseInt(yy, 10);
                    if (yy.length === 2) {
                        year += 2000; // assume 2000s for two-digit years
                    }
                    d = new Date(year, monthIdx, day);
                    if (!isNaN(d)) return d;
                }
            }

            return null;
        }

        // Detecta si la mayor√≠a de fechas en una columna usan MDY (MM/DD/YYYY) o DMY (DD/MM/YYYY)
        function guessDateOrderFromSamples(data, fieldName) {
            if (!data || !data.length) return null;
            const maxSamples = 200;
            const currentYear = new Date().getFullYear();
            let mdyCount = 0;
            let dmyCount = 0;
            let samples = 0;

            for (let i = 0; i < data.length && samples < maxSamples; i++) {
                const row = data[i];
                const raw = row[fieldName];
                if (!raw && raw !== 0) continue;
                const s = String(raw).trim();
                const m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
                if (!m) continue;
                samples++;
                const p1 = parseInt(m[1], 10);
                const p2 = parseInt(m[2], 10);
                const year = parseInt(m[3], 10);

                // Construir fechas y contabilizar si parecen plausibles
                const dmy = new Date(year, p2 - 1, p1);
                const mdy = new Date(year, p1 - 1, p2);

                const validDMY = (!isNaN(dmy) && dmy.getFullYear() === year && year > 1900 && year <= currentYear + 1);
                const validMDY = (!isNaN(mdy) && mdy.getFullYear() === year && year > 1900 && year <= currentYear + 1);

                if (validMDY && !validDMY) mdyCount++;
                else if (validDMY && !validMDY) dmyCount++;
                else {
                    // Ambos v√°lidos (ambig√ºedad) -> intentar heur√≠stica: si p1 > 12 then it's day etc.
                    if (p1 > 12 && p2 <= 12) dmyCount++;
                    else if (p2 > 12 && p1 <= 12) mdyCount++;
                    else {
                        // Si ambos <=12, preferir MDY (Google Sheets suele devolver mm/dd/yyyy cuando la hoja est√° en formato US)
                        mdyCount++;
                    }
                }
            }

            if (samples === 0) return null;
            return (mdyCount >= dmyCount) ? 'MDY' : 'DMY';
        }

        function getFilteredData() {
            let filtered = baseData;
            const initialCount = filtered.length;

            // Solo aplicar filtro de a√±o si NO estamos filtrando por semana o mes espec√≠fico
            // (porque SEM y MES ya son espec√≠ficos y no dependen de FECHA CORTE)
            const isFilteringByPeriod = (currentFilters.periodType === 'week' && currentFilters.week) || 
                                       (currentFilters.periodType === 'month' && currentFilters.month);
            
            if (currentFilters.year && !isFilteringByPeriod) {
                // Usar m√∫ltiples fuentes para el a√±o: columna directa A√ëO/ANO o _year calculado
                filtered = filtered.filter(r => {
                    const yearFromColumn = toNum(r['A√ëO']) || toNum(r.A√ëO) || toNum(r.ANO);
                    const yearFromDate = r._year;
                    return yearFromColumn == currentFilters.year || yearFromDate == currentFilters.year;
                });
                console.log(`Filtro a√±o ${currentFilters.year}: ${filtered.length} de ${initialCount} filas`);
            }

            if (currentFilters.periodType === 'month' && currentFilters.month) {
                const beforeMonth = filtered.length;
                filtered = filtered.filter(r => r._month == currentFilters.month);
                console.log(`Filtro mes ${currentFilters.month}: ${filtered.length} de ${beforeMonth} filas`);
            }

            if (currentFilters.periodType === 'week' && currentFilters.week) {
                const beforeWeek = filtered.length;
                // Usar la columna SEM del sheet en lugar de _week calculado para coincidir con el filtro manual
                filtered = filtered.filter(r => toNum(r.SEM) == currentFilters.week || r._week == currentFilters.week);
                console.log(`Filtro semana ${currentFilters.week}: ${filtered.length} de ${beforeWeek} filas`);
            }

            if (currentFilters.cliente) {
                const beforeCliente = filtered.length;
                filtered = filtered.filter(r => r.CLIENTE === currentFilters.cliente);
                console.log(`Filtro cliente ${currentFilters.cliente}: ${filtered.length} de ${beforeCliente} filas`);
            }

            console.log(`‚úì Total filas filtradas: ${filtered.length}`);
            
            // Guardar para diagn√≥stico
            diagnosticData.filteredCount = filtered.length;
            if (typeof updateDiagnosticPanel === 'function') updateDiagnosticPanel();
            
            return filtered;
        }

        function getFilteredProdCorteData() {
            let filtered = prodCorteData;

            if (currentFilters.year) {
                filtered = filtered.filter(r => toNum(r['A√ëO']) == currentFilters.year || toNum(r.A√ëO) == currentFilters.year);
            }

            if (currentFilters.periodType === 'month' && currentFilters.month) {
                const monthNum = toNum(currentFilters.month);
                const monthNamesUpper = ['ENERO','FEBRERO','MARZO','ABRIL','MAYO','JUNIO','JULIO','AGOSTO','SEPTIEMBRE','OCTUBRE','NOVIEMBRE','DICIEMBRE'];
                filtered = filtered.filter(r => {
                    const raw = r.MES !== undefined ? r.MES : r['MES'];
                    const rawNum = toNum(raw);
                    if (!isNaN(rawNum) && monthNum && rawNum == monthNum) return true;
                    if (raw) {
                        const s = raw.toString().trim().toUpperCase();
                        if (monthNamesUpper.includes(s)) return (monthNamesUpper.indexOf(s) + 1) === monthNum;
                        const short = s.slice(0,3);
                        const shortNames = monthNamesUpper.map(m => m.slice(0,3));
                        if (shortNames.includes(short)) return (shortNames.indexOf(short) + 1) === monthNum;
                    }
                    return false;
                });
            }

            if (currentFilters.periodType === 'week' && currentFilters.week) {
                filtered = filtered.filter(r => toNum(r.SEM) == currentFilters.week);
            }

            if (currentFilters.cliente) {
                filtered = filtered.filter(r => r.CLIENTE === currentFilters.cliente);
            }

            return filtered;
        }

        function calculateKPIs(data, prodCorteFiltered) {
            // Calcular Prendas Cortadas desde la hoja prod_corte
            let totalPrendasCortadas = 0;
            let totalCantidadRevisada = 0;
            if (prodCorteFiltered && prodCorteFiltered.length > 0) {
                prodCorteFiltered.forEach(row => {
                    // Obtener la cantidad cortada de la columna CANTIDAD CORTADA
                    const cantidad = toNum(row['CANTIDAD CORTADA']) || toNum(row.CANTIDAD_CORTADA) || 0;
                    totalPrendasCortadas += cantidad;
                    
                    // Obtener la cantidad revisada de la columna CANTIDAD REVISADA
                    const cantidadRevisada = toNum(row['CANTIDAD REVISADA']) || toNum(row.CANTIDAD_REVISADA) || 0;
                    totalCantidadRevisada += cantidadRevisada;
                });
            }
            
            let totalPrendasDepuradas = 0;
            let totalPrendasRecuperadas = 0;
            let totalPerdidaNeta = 0;
            let totalPiezasDefectuosas = 0;

            data.forEach(row => {
                // Intentar m√∫ltiples variantes del nombre de columna CANT. DEPURADO
                const depurado = toNum(row['CANT. DEPURADO']) || 
                                toNum(row['CANT DEPURADO']) || 
                                toNum(row['CANT.DEPURADO']) || 
                                toNum(row['CANT. DEPL']) ||
                                toNum(row['CANT DEPL']) ||
                                toNum(row.CANT_DEPURADO) || 
                                toNum(row.CANT_DEPL) || 
                                0;
                totalPrendasDepuradas += depurado;
                totalPrendasRecuperadas += toNum(row.RECUPERADOS) || toNum(row.RECUPERADO) || 0;
                totalPerdidaNeta += toNum(row['REAL NO RECUPERADO']) || toNum(row.REAL_NO_RECUPERADO) || 0;
                
                defectColumns.forEach(col => {
                    totalPiezasDefectuosas += toNum(row[col]);
                });
            });

            const tasaRevisada = totalPrendasCortadas > 0 ? (totalCantidadRevisada / totalPrendasCortadas) * 100 : 0;
            const tasaDepurado = totalPrendasCortadas > 0 ? (totalPrendasDepuradas / totalPrendasCortadas) * 100 : 0;
            const tasaDepuradoRevisada = totalCantidadRevisada > 0 ? (totalPrendasDepuradas / totalCantidadRevisada) * 100 : 0;
            const tasaRecuperadosCortadas = totalPrendasCortadas > 0 ? (totalPrendasRecuperadas / totalPrendasCortadas) * 100 : 0;
            const tasaRecuperadosRevisada = totalCantidadRevisada > 0 ? (totalPrendasRecuperadas / totalCantidadRevisada) * 100 : 0;
            const tasaRecuperacion = totalPrendasDepuradas > 0 ? (totalPrendasRecuperadas / totalPrendasDepuradas) * 100 : 0;
            const tasaPerdida = totalPrendasCortadas > 0 ? (totalPerdidaNeta / totalPrendasCortadas) * 100 : 0;
            const tasaPerdidaRevisada = totalCantidadRevisada > 0 ? (totalPerdidaNeta / totalCantidadRevisada) * 100 : 0;

            return {
                totalPrendasCortadas,
                totalCantidadRevisada,
                totalPrendasDepuradas,
                totalPrendasRecuperadas,
                totalPerdidaNeta,
                totalPiezasDefectuosas,
                tasaRevisada,
                tasaDepurado,
                tasaDepuradoRevisada,
                tasaRecuperadosCortadas,
                tasaRecuperadosRevisada,
                tasaRecuperacion,
                tasaPerdida,
                tasaPerdidaRevisada,
                totalRegistros: data.length
            };
        }

        function renderKPIs(kpis) {
            const kpiSection = document.getElementById('kpiSection');

            kpiSection.innerHTML = `
                <div class="kpi-card">
                    <div class="kpi-label">Pds Corte</div>
                    <div class="kpi-row">
                        <div class="kpi-value">${formatNum(kpis.totalPrendasCortadas)} pds</div>
                    </div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-label">Pds Rev.</div>
                    <div class="kpi-row">
                        <div class="kpi-value">[${formatNum(kpis.totalCantidadRevisada)}]</div>
                        <div class="kpi-subvalue"><span class="kpi-percent">${formatPercent(kpis.tasaRevisada, 2)}</span></div>
                    </div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-label">Prendas Depuradas</div>
                    <div class="kpi-row">
                        <div class="kpi-value">${formatNum(kpis.totalPrendasDepuradas)}</div>
                        <div class="kpi-subvalue"><span class="kpi-percent">${formatPercent(kpis.tasaDepurado, 2)}</span> [<span class="kpi-percent">${formatPercent(kpis.tasaDepuradoRevisada, 2)}</span>]</div>
                    </div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-label">Prendas Recuperadas</div>
                    <div class="kpi-row">
                        <div class="kpi-value">${formatNum(kpis.totalPrendasRecuperadas)}</div>
                        <div class="kpi-subvalue"><span class="kpi-percent">${formatPercent(kpis.tasaRecuperadosCortadas, 2)}</span> [<span class="kpi-percent">${formatPercent(kpis.tasaRecuperadosRevisada, 2)}</span>]</div>
                    </div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-label">Real no recuperado</div>
                    <div class="kpi-row">
                        <div class="kpi-value">${formatNum(kpis.totalPerdidaNeta)}</div>
                        <div class="kpi-subvalue"><span class="kpi-percent">${formatPercent(kpis.tasaPerdida, 2)}</span> [<span class="kpi-percent">${formatPercent(kpis.tasaPerdidaRevisada, 2)}</span>]</div>
                    </div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-label">Piezas Defectuosas</div>
                    <div class="kpi-row">
                        <div class="kpi-value">${formatNum(kpis.totalPiezasDefectuosas)}</div>
                    </div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-label">Eficiencia Global</div>
                    <div class="kpi-row">
                        <div class="kpi-value">${formatPercent(100 - kpis.tasaPerdida, 1)}</div>
                        <div class="kpi-subvalue">${100 - kpis.tasaPerdida > 95 ? '‚úÖ √ìptimo' : '‚ö†Ô∏è Mejorar'}</div>
                    </div>
                </div>
            `;
        }

        function calculatePareto(data) {
            const defectTotals = {};

            defectColumns.forEach(col => {
                defectTotals[col] = 0;
            });

            data.forEach(row => {
                defectColumns.forEach(col => {
                    defectTotals[col] += toNum(row[col]);
                });
            });

            const sorted = Object.entries(defectTotals)
                .filter(([_, value]) => value > 0)
                .sort((a, b) => b[1] - a[1]);

            const total = sorted.reduce((sum, [_, value]) => sum + value, 0);
            
            let cumulative = 0;
            const paretoData = sorted.map(([defect, value]) => {
                cumulative += value;
                return {
                    defect: defect.length > 25 ? defect.substring(0, 22) + '...' : defect,
                    fullDefect: defect,
                    value,
                    percent: total > 0 ? (value / total) * 100 : 0,
                    cumulative: total > 0 ? (cumulative / total) * 100 : 0
                };
            });

            return paretoData;
        }

        function renderParetoChart(paretoData) {
            const canvas = document.getElementById('paretoChart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const top10 = paretoData.slice(0, 10);
            // Array de banderas para marcar ticks/points con % acumulado <= 82
            const highlightTicks = top10.map(d => d.cumulative <= 82);

            // Destruir gr√°fico anterior si existe
            if (paretoChart) {
                paretoChart.destroy();
            }

            paretoChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: top10.map(d => d.defect),
                    datasets: [
                        {
                            type: 'bar',
                            label: 'Piezas Defectuosas',
                            data: top10.map(d => d.value),
                            backgroundColor: 'rgba(30, 60, 114, 0.85)',
                            borderColor: 'rgba(30, 60, 114, 1)',
                            borderWidth: 1,
                            yAxisID: 'y',
                            // Mostrar etiquetas: centradas dentro de la barra
                            // salvo cuando la barra es muy peque√±a -> colocar fuera (arriba)
                            datalabels: {
                                display: true,
                                color: function(ctx) {
                                    try {
                                        const chart = ctx.chart;
                                        const meta = chart.getDatasetMeta(ctx.datasetIndex);
                                        const bar = meta.data[ctx.dataIndex];
                                        if (!bar) return '#ffffff';
                                        const barHeight = Math.abs(bar.y - bar.base);
                                        return barHeight < 24 ? '#000000' : '#ffffff';
                                    } catch (e) {
                                        return '#ffffff';
                                    }
                                },
                                anchor: function(ctx) {
                                    try {
                                        const chart = ctx.chart;
                                        const meta = chart.getDatasetMeta(ctx.datasetIndex);
                                        const bar = meta.data[ctx.dataIndex];
                                        if (!bar) return 'center';
                                        const barHeight = Math.abs(bar.y - bar.base);
                                        return barHeight < 24 ? 'end' : 'center';
                                    } catch (e) {
                                        return 'center';
                                    }
                                },
                                align: function(ctx) {
                                    try {
                                        const chart = ctx.chart;
                                        const meta = chart.getDatasetMeta(ctx.datasetIndex);
                                        const bar = meta.data[ctx.dataIndex];
                                        if (!bar) return 'center';
                                        const barHeight = Math.abs(bar.y - bar.base);
                                        return barHeight < 24 ? 'end' : 'center';
                                    } catch (e) {
                                        return 'center';
                                    }
                                },
                                offset: function(ctx) {
                                    try {
                                        const chart = ctx.chart;
                                        const meta = chart.getDatasetMeta(ctx.datasetIndex);
                                        const bar = meta.data[ctx.dataIndex];
                                        if (!bar) return 0;
                                        const barHeight = Math.abs(bar.y - bar.base);
                                        return barHeight < 24 ? -6 : 0;
                                    } catch (e) {
                                        return 0;
                                    }
                                },
                                clamp: true,
                                formatter: function(value) {
                                    return formatNum(value);
                                },
                                font: {
                                    family: 'Calibri, sans-serif',
                                    size: 14,
                                    weight: 'bold'
                                }
                            }
                        },
                        {
                            type: 'line',
                            label: '% Acumulado (80/20)',
                            data: top10.map(d => d.cumulative),
                            borderColor: 'rgba(231, 76, 60, 1)',
                            backgroundColor: 'rgba(231, 76, 60, 0.1)',
                            borderWidth: 3,
                            yAxisID: 'y1',
                            tension: 0.3,
                            // Mostrar punto visible solo si el % acumulado es <= 82
                            pointRadius: top10.map(d => d.cumulative <= 82 ? 5 : 0),
                            pointHoverRadius: top10.map(d => d.cumulative <= 82 ? 6 : 0),
                            pointBackgroundColor: top10.map(d => d.cumulative <= 82 ? 'rgba(231, 76, 60, 1)' : 'rgba(231,76,60,0.25)'),
                            pointBorderColor: '#fff',
                            pointBorderWidth: 2,
                            // Configuraci√≥n de datalabels espec√≠fica para esta serie: mostrar solo valores <=82%
                            datalabels: {
                                // Mostrar solo para los puntos resaltados (<=82%) y colocarlo encima
                                display: function(ctx) {
                                    const idx = ctx.dataIndex;
                                    return (typeof highlightTicks !== 'undefined' && highlightTicks[idx]);
                                },
                                formatter: function(value) {
                                    return value.toFixed(1) + '%';
                                },
                                color: 'rgba(231, 76, 60, 1)',
                                font: {
                                    family: 'Calibri, sans-serif',
                                    size: 12,
                                    weight: 'bold'
                                },
                                anchor: 'end',
                                align: 'top',
                                offset: -2
                            }
                        }
                    ]
                },
                options: {
                    // Cuando se hace click en una barra, mostramos el men√∫ contextual
                    onClick: function(evt) {
                        try {
                            const points = paretoChart.getElementsAtEventForMode(evt, 'nearest', { intersect: true }, true) || [];
                            if (points.length === 0) return;
                            const p = points[0];
                            // datasetIndex 0 corresponde a las barras (Piezas Defectuosas)
                            if (p.datasetIndex !== 0) return;
                            const idx = p.index;
                            const defectName = top10[idx].fullDefect;
                            
                            // Mostrar men√∫ contextual en la posici√≥n del click
                            showContextMenu(evt.native.pageX, evt.native.pageY, defectName);
                        } catch (e) {
                            console.error('Error en onClick paretoChart:', e);
                        }
                    },
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            align: 'start',
                            labels: {
                                font: { family: 'Calibri, sans-serif', size: 12 },
                                padding: 8,
                                boxWidth: 16
                            }
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const idx = context[0].dataIndex;
                                    return top10[idx].fullDefect;
                                },
                                label: function(context) {
                                    if (context.dataset.type === 'line') {
                                        return 'Acumulado: ' + context.parsed.y.toFixed(1) + '%';
                                    }
                                    const idx = context.dataIndex;
                                    return 'Piezas: ' + formatNum(context.parsed.y) + ' (' + top10[idx].percent.toFixed(1) + '%)';
                                }
                            }
                        },
                        datalabels: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                // Resaltar en negro y negrita los defectos que tienen datos en la gr√°fica de puntos/lineas
                                color: function(ctx) {
                                    const idx = ctx.index;
                                    return (typeof highlightTicks !== 'undefined' && highlightTicks[idx]) ? '#000' : '#666';
                                },
                                font: function(ctx) {
                                    const idx = ctx.index;
                                    const isHl = (typeof highlightTicks !== 'undefined' && highlightTicks[idx]);
                                    return {
                                        family: 'Calibri, sans-serif',
                                        size: 15,
                                        weight: isHl ? '700' : '400'
                                    };
                                },
                                maxRotation: 90,
                                minRotation: 90
                            }
                        },
                        y: {
                            type: 'linear',
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Cantidad de Piezas',
                                font: { size: 10 }
                            },
                            ticks: {
                                font: { size: 9 }
                            }
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            title: {
                                display: true,
                                text: '% Acumulado',
                                font: { size: 10 }
                            },
                            min: 0,
                            max: 100,
                            grid: {
                                drawOnChartArea: false
                            },
                            ticks: {
                                font: { size: 9 },
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        }
                    }
                }
            });
        }

        function calculateFactoryComparison(data) {
            const factoryData = {};

            data.forEach(row => {
                const factory = row.FACTORY_CODE || 'Sin Factory';
                if (!factoryData[factory]) {
                    factoryData[factory] = {
                        cortadas: 0,
                        perdidaNeta: 0
                    };
                }

                factoryData[factory].cortadas += toNum(row['CANT. CORTADA']);
                factoryData[factory].perdidaNeta += toNum(row['REAL NO RECUPERADO']);
            });

            return Object.keys(factoryData)
                .filter(f => f !== 'Sin Factory')
                .map(factory => ({
                    factory,
                    cortadas: factoryData[factory].cortadas,
                    perdidaNeta: factoryData[factory].perdidaNeta,
                    tasaPerdida: factoryData[factory].cortadas > 0 
                        ? (factoryData[factory].perdidaNeta / factoryData[factory].cortadas) * 100 
                        : 0
                }))
                .sort((a, b) => a.tasaPerdida - b.tasaPerdida);
        }

        // Variables globales para el men√∫ contextual
        let currentDefectForMenu = null;

        function showContextMenu(x, y, defectName) {
            const menu = document.getElementById('defectContextMenu');
            currentDefectForMenu = defectName;
            
            // Posicionar el men√∫
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.style.display = 'block';
            
            // Cerrar men√∫ al hacer click fuera
            setTimeout(() => {
                document.addEventListener('click', closeContextMenu);
            }, 0);
        }

        function closeContextMenu() {
            const menu = document.getElementById('defectContextMenu');
            menu.style.display = 'none';
            document.removeEventListener('click', closeContextMenu);
        }

        function showDefectTrendModal(defectName) {
            const modal = document.getElementById('trendModal');
            const title = document.getElementById('trendModalTitle');
            const ctx = document.getElementById('trendChart');
            // Guardar defecto actual para acciones r√°pidas
            window.currentTrendDefect = defectName;
            
            title.textContent = `Tendencia: ${defectName}`;
            
            // Obtener la semana actual del usuario (√∫ltima semana en los datos filtrados)
            const filteredData = getFilteredData();
            const allWeeks = filteredData.map(r => toNum(r.SEM)).filter(w => w > 0);
            const currentWeek = allWeeks.length > 0 ? Math.max(...allWeeks) : 49;
            
            // Calcular las √∫ltimas 10 semanas (desde currentWeek-9 hasta currentWeek)
            const weeks = [];
            for (let i = 9; i >= 0; i--) {
                const weekNum = currentWeek - i;
                if (weekNum > 0) {
                    weeks.push(weekNum);
                }
            }
            
            // Agrupar datos por semana
            const weeklyData = {};
            weeks.forEach(w => {
                weeklyData[w] = {
                    defectCount: 0,
                    prendasDepuradas: 0,
                    pdsRev: 0,
                    piezasDefectuosas: 0
                };
            });
            
            // Procesar baseData para defectos, prendas depuradas y piezas defectuosas
            baseData.forEach(row => {
                const sem = toNum(row.SEM);
                if (!sem || !weeklyData[sem]) return;
                
                const defectValue = toNum(row[defectName]);
                
                // Prendas Depuradas = CANT. DEPURADO
                const prendasDep = toNum(row['CANT. DEPURADO']) || 
                                   toNum(row['CANT DEPURADO']) || 
                                   toNum(row['CANT.DEPURADO']) || 
                                   toNum(row['CANT. DEPL']) ||
                                   toNum(row['CANT DEPL']) ||
                                   toNum(row.CANT_DEPURADO) || 
                                   toNum(row.CANT_DEPL) || 
                                   0;
                
                // Sumar todas las piezas defectuosas de la fila
                let totalDefects = 0;
                defectColumns.forEach(col => {
                    totalDefects += toNum(row[col]);
                });
                
                weeklyData[sem].defectCount += defectValue;
                weeklyData[sem].prendasDepuradas += prendasDep;
                weeklyData[sem].piezasDefectuosas += totalDefects;
            });
            
            // Procesar prodCorteData para Pds Rev. (CANTIDAD REVISADA)
            prodCorteData.forEach(row => {
                const sem = toNum(row.SEM);
                if (!sem || !weeklyData[sem]) return;
                
                const cantidadRevisada = toNum(row['CANTIDAD REVISADA']) || toNum(row.CANTIDAD_REVISADA) || 0;
                weeklyData[sem].pdsRev += cantidadRevisada;
            });
            
            // Preparar datos para el gr√°fico
            const labels = weeks.map(w => `SEM${w}`);
            const defectCounts = weeks.map(w => weeklyData[w].defectCount);
            const pdsRevCounts = weeks.map(w => weeklyData[w].pdsRev);
            const prendasDepCounts = weeks.map(w => weeklyData[w].prendasDepuradas);
            const piezasDefCounts = weeks.map(w => weeklyData[w].piezasDefectuosas);
            
            // Calcular porcentajes: (Prendas Depuradas / Pds Rev.) * (SUMA defecto / Piezas Defectuosas) * 100
            const percentages = weeks.map(w => {
                const data = weeklyData[w];
                
                // Debug
                console.log(`SEM${w}:`, {
                    prendasDep: data.prendasDepuradas,
                    pdsRev: data.pdsRev,
                    defectCount: data.defectCount,
                    piezasDefectuosas: data.piezasDefectuosas
                });
                
                // Si no hay datos, retornar 0 en lugar de null para que se vea en el gr√°fico
                if (data.pdsRev === 0 || data.piezasDefectuosas === 0) {
                    console.log(`SEM${w}: Sin datos v√°lidos (pdsRev=${data.pdsRev}, piezasDefectuosas=${data.piezasDefectuosas})`);
                    return 0;
                }
                
                const ratio1 = data.prendasDepuradas / data.pdsRev;
                const ratio2 = data.defectCount / data.piezasDefectuosas;
                const percentage = ratio1 * ratio2 * 100;
                
                console.log(`SEM${w}: ratio1=${ratio1.toFixed(4)}, ratio2=${ratio2.toFixed(4)}, %=${percentage.toFixed(2)}`);
                
                return percentage;
            });
            
            console.log('=== RESUMEN DATOS TENDENCIA ===');
            console.log('Defecto:', defectName);
            console.log('Semanas:', weeks);
            console.log('Pds Rev:', pdsRevCounts);
            console.log('Piezas Defecto:', defectCounts);
            console.log('Porcentajes:', percentages);
            console.log('==============================');
            
            // Calcular el m√°ximo din√°mico para el eje Y1 (porcentaje)
            const validPercentages = percentages.filter(p => p > 0);
            const maxPercentage = validPercentages.length > 0 ? Math.max(...validPercentages) : 1;
            // Redondear hacia arriba al siguiente entero
            const dynamicMax = Math.ceil(maxPercentage);
            console.log(`Max % encontrado: ${maxPercentage.toFixed(2)}%, Eje Y1 max: ${dynamicMax}%`);
            
            // Destruir gr√°fico anterior si existe
            if (window.trendChartInstance) {
                window.trendChartInstance.destroy();
            }
            
            // Crear nuevo gr√°fico
            window.trendChartInstance = new Chart(ctx, {
                data: {
                    labels: labels,
                    datasets: [
                        {
                            type: 'bar',
                            label: 'Pds Rev.',
                            data: pdsRevCounts,
                            backgroundColor: 'rgba(75, 192, 192, 0.5)',
                            borderColor: 'rgba(75, 192, 192, 1)',
                            borderWidth: 1,
                            yAxisID: 'y',
                            order: 2,
                            datalabels: {
                                display: true,
                                align: 'end',
                                anchor: 'end',
                                offset: -2,
                                color: '#000',
                                font: {
                                    family: 'Calibri, sans-serif',
                                    size: 14,
                                    weight: 'bold'
                                },
                                formatter: function(value) {
                                    if (value === 0) return '';
                                    return formatNum(value);
                                }
                            }
                        },
                        {
                            type: 'bar',
                            label: 'Cantidad de Piezas (Defecto)',
                            data: defectCounts,
                            backgroundColor: 'rgba(54, 162, 235, 0.7)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1,
                            yAxisID: 'y',
                            order: 3,
                            datalabels: {
                                display: true,
                                align: 'end',
                                anchor: 'end',
                                offset: -2,
                                color: '#000',
                                font: {
                                    family: 'Calibri, sans-serif',
                                    size: 14,
                                    weight: 'bold'
                                },
                                formatter: function(value) {
                                    if (value === 0) return '';
                                    return formatNum(value);
                                }
                            }
                        },
                        {
                            type: 'line',
                            label: '% del Defecto',
                            data: percentages,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            borderWidth: 3,
                            pointRadius: 6,
                            pointBackgroundColor: 'rgba(255, 99, 132, 1)',
                            pointBorderColor: '#fff',
                            pointBorderWidth: 2,
                            yAxisID: 'y1',
                            tension: 0.3,
                            spanGaps: true,
                            fill: false,
                            order: 1,
                            datalabels: {
                                display: true,
                                align: 'top',
                                anchor: 'end',
                                offset: 4,
                                color: '#ff0000',
                                font: {
                                    family: 'Calibri, sans-serif',
                                    size: 14,
                                    weight: 'bold'
                                },
                                formatter: function(value) {
                                    if (value === null || value === 0) return '';
                                    return value.toFixed(2) + '%';
                                }
                            }
                        }
                    ]
                },
                plugins: [ChartDataLabels],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        datalabels: {
                            display: false
                        },
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                font: { size: 12 },
                                padding: 10
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.dataset.type === 'line') {
                                        if (context.parsed.y === null) return null;
                                        return '% del Defecto: ' + context.parsed.y.toFixed(2) + '%';
                                    }
                                    return context.dataset.label + ': ' + formatNum(context.parsed.y);
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Pds Rev. / Cantidad de Piezas',
                                font: { size: 12 }
                            },
                            beginAtZero: true
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            title: {
                                display: true,
                                text: '% del Defecto',
                                font: { size: 12 },
                                color: 'rgba(255, 99, 132, 1)'
                            },
                            beginAtZero: true,
                            max: dynamicMax,
                            grid: {
                                drawOnChartArea: false
                            },
                            ticks: {
                                color: 'rgba(255, 99, 132, 1)',
                                callback: function(value) {
                                    return value.toFixed(2) + '%';
                                }
                            }
                        }
                    }
                }
            });
            
            // Mostrar modal
            modal.style.display = 'flex';
            
            // Bind cierre
            const closeBtn = document.getElementById('trendModalClose');
            function close() {
                modal.style.display = 'none';
            }
            closeBtn.onclick = close;
            modal.onclick = function(e) {
                if (e.target === modal) close();
            };
        }

        // Mostrar modal con tabla de detalle para un defecto
        function showDefectModal(defectName, rows) {
            const modal = document.getElementById('defectModal');
            const title = document.getElementById('defectModalTitle');
            const thead = document.getElementById('defectModalHead');
            const tbody = document.getElementById('defectModalBody');

            title.textContent = `Detalle: ${defectName}`;

            // Encabezados: CLIENTE, OP_TELA-PTDA, OP, COLOR, <defecto>
            const headers = ['CLIENTE', 'OP_TELA-PTDA', 'OP', 'COLOR', defectName];

            // Limpiar thead / tbody
            thead.innerHTML = '';
            tbody.innerHTML = '';

            headers.forEach(h => {
                const th = document.createElement('th');
                th.textContent = h;
                thead.appendChild(th);
            });

            // Funci√≥n para sanear valores tipo '1000039579' -> '39579'
            function sanitizeRemoveLeading1(val) {
                if (val === undefined || val === null) return '';
                const s = String(val).trim();
                if (s === '') return '';
                // Si el primer car√°cter es '1', eliminarlo
                let cleaned = s;
                if (cleaned.charAt(0) === '1') cleaned = cleaned.slice(1);
                // Convertir a entero para eliminar ceros a la izquierda
                const n = parseInt(cleaned, 10);
                return isNaN(n) ? cleaned : String(n);
            }

            // Ordenar filas por la columna del defecto (descendente)
            rows.sort((a, b) => toNum(b[defectName]) - toNum(a[defectName]));

            // Construir filas y alternar color por cambios en OP_TELA-PTDA
            let prevCombined = null;
            let paint = false;
            rows.forEach(r => {
                const tr = document.createElement('tr');

                const cliente = r.CLIENTE || r.Cliente || '';
                const op_tela_raw = r.OP_TELA || r['OP_TELA'] || r['OP TELA'] || r.Op_Tela || '';
                const ptda_raw = (r.PTDA !== undefined && r.PTDA !== null) ? r.PTDA : (r.PTDS !== undefined ? r.PTDS : '');
                const op_raw = r.OP || r.Op || '';
                const color = r.COLOR || r.Color || '';

                const op_tela_clean = sanitizeRemoveLeading1(op_tela_raw);
                const op_clean = sanitizeRemoveLeading1(op_raw);
                const ptda_clean = (ptda_raw === undefined || ptda_raw === null || ptda_raw === '') ? '' : String(parseInt(ptda_raw, 10));

                const combined = ptda_clean ? `${op_tela_clean}-${ptda_clean}` : op_tela_clean;

                // Alternar pintura cuando cambia el valor combinado
                if (combined !== prevCombined) {
                    paint = !paint;
                    prevCombined = combined;
                }

                if (paint) {
                    tr.style.backgroundColor = 'rgb(230,230,230)';
                }

                const cols = [cliente, combined, op_clean, color];

                cols.forEach(v => {
                    const td = document.createElement('td');
                    td.textContent = (v === undefined || v === null) ? '' : String(v);
                    tr.appendChild(td);
                });

                const defectValTd = document.createElement('td');
                defectValTd.textContent = formatNum(toNum(r[defectName]));
                tr.appendChild(defectValTd);

                tbody.appendChild(tr);
            });

            // Mostrar modal
            modal.style.display = 'flex';

            // Bind cierre (bot√≥n superior) y cierre al clicar fuera
            const closeBtn = document.getElementById('defectModalClose');
            function close() {
                modal.style.display = 'none';
                tbody.innerHTML = '';
            }
            closeBtn.onclick = close;
            // Cerrar al clickear fuera del contenido
            modal.onclick = function(e) {
                if (e.target === modal) close();
            };
        }

        function showTelaDetail(telaName) {
            const modal = document.getElementById('telaDetailModal');
            const title = document.getElementById('telaDetailModalTitle');
            const thead = document.getElementById('telaDetailHead');
            const tbody = document.getElementById('telaDetailBody');

            title.textContent = `Detalle de TELA: ${telaName}`;

            // Obtener filtros actuales del modal TELA
            const year = document.getElementById('telaYearSelect').value;
            const periodType = document.getElementById('telaPeriodTypeSelect').value;
            const week = document.getElementById('telaWeekSelect').value;
            const month = document.getElementById('telaMonthSelect').value;
            const cliente = document.getElementById('telaClienteSelect').value;

            // Filtrar datos con los mismos filtros del modal TELA + coincidencia de TELA
            let filteredRows = (baseData || []).filter(r => {
                const tela = (r.TELA !== undefined && r.TELA !== null) ? String(r.TELA).trim() : '';
                const normalizedTela = tela ? tela.toUpperCase().replace(/"/g, '') : '';
                if (normalizedTela !== telaName) return false;
                
                // Aplicar los mismos filtros que en buildTelaResumenTable
                if (year && r._year && String(r._year) !== String(year)) return false;
                if (periodType === 'week' && week) {
                    if (!((r._week && String(r._week) === String(week)) || (r.SEM && String(r.SEM) === String(week)))) return false;
                }
                if (periodType === 'month' && month) {
                    if (!((r._month && String(r._month) === String(month)) || (r.MES && String(r.MES) === String(month)))) return false;
                }
                if (cliente && r.CLIENTE !== cliente) return false;
                
                return true;
            });

            // Funci√≥n para sanear valores
            function sanitizeRemoveLeading1(val) {
                if (val === undefined || val === null) return '';
                const s = String(val).trim();
                if (s === '') return '';
                let cleaned = s;
                if (cleaned.charAt(0) === '1') cleaned = cleaned.slice(1);
                const n = parseInt(cleaned, 10);
                return isNaN(n) ? cleaned : String(n);
            }

            // Determinar qu√© columnas de defectos tienen datos (al menos un valor > 0)
            const defectsWithData = [];
            (defectColumns || []).forEach(col => {
                const hasData = filteredRows.some(r => toNum(r[col]) > 0);
                if (hasData) {
                    defectsWithData.push(col);
                }
            });

            // Construir encabezados: OP_TELA-PTDA, COLOR, + columnas de defectos con datos
            const headers = ['OP_TELA-PTDA', 'COLOR'];
            defectsWithData.forEach(col => headers.push(col));

            thead.innerHTML = '';
            tbody.innerHTML = '';

            const trh = document.createElement('tr');
            headers.forEach(h => {
                const th = document.createElement('th');
                th.textContent = h;
                th.style.padding = '6px';
                th.style.borderBottom = '1px solid #ddd';
                th.style.backgroundColor = 'rgb(43,108,167)';
                th.style.color = '#fff';
                th.style.textAlign = (h === 'OP_TELA-PTDA' || h === 'COLOR') ? 'left' : 'right';
                trh.appendChild(th);
            });
            thead.appendChild(trh);

            // Construir filas
            filteredRows.forEach(r => {
                const tr = document.createElement('tr');

                const op_tela_raw = r.OP_TELA || r['OP_TELA'] || r['OP TELA'] || r.Op_Tela || '';
                const ptda_raw = (r.PTDA !== undefined && r.PTDA !== null) ? r.PTDA : (r.PTDS !== undefined ? r.PTDS : '');
                const color = r.COLOR || r.Color || '';

                const op_tela_clean = sanitizeRemoveLeading1(op_tela_raw);
                const ptda_clean = (ptda_raw === undefined || ptda_raw === null || ptda_raw === '') ? '' : String(parseInt(ptda_raw, 10));

                // OP_TELA-PTDA concatenado
                const tdOpTelaPtda = document.createElement('td');
                const combined = ptda_clean ? `${op_tela_clean}-${ptda_clean}` : op_tela_clean;
                tdOpTelaPtda.textContent = combined;
                tdOpTelaPtda.style.padding = '4px';
                tdOpTelaPtda.style.borderBottom = '1px solid #f0f0f0';
                tdOpTelaPtda.style.textAlign = 'left';
                tr.appendChild(tdOpTelaPtda);

                // COLOR - normalizar HEATHERED a HTR
                const tdColor = document.createElement('td');
                const normalizedColor = color.replace(/HEATHERED/gi, 'HTR');
                tdColor.textContent = normalizedColor;
                tdColor.style.padding = '4px';
                tdColor.style.borderBottom = '1px solid #f0f0f0';
                tdColor.style.textAlign = 'left';
                tr.appendChild(tdColor);

                // Columnas de defectos - solo las que tienen datos
                defectsWithData.forEach(defCol => {
                    const tdDef = document.createElement('td');
                    const val = toNum(r[defCol]);
                    tdDef.textContent = val > 0 ? formatNum(val) : '';
                    tdDef.style.padding = '4px';
                    tdDef.style.borderBottom = '1px solid #f0f0f0';
                    tdDef.style.textAlign = 'right';
                    tr.appendChild(tdDef);
                });

                tbody.appendChild(tr);
            });

            // Mostrar modal
            modal.style.display = 'flex';

            // Bind cierre
            const closeBtn = document.getElementById('telaDetailModalClose');
            function close() {
                modal.style.display = 'none';
                tbody.innerHTML = '';
            }
            closeBtn.onclick = close;
            modal.onclick = function(e) {
                if (e.target === modal) close();
            };
        }

        function renderFactoryChart(factoryData) {
            const canvas = document.getElementById('factoryChart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');

            // Destruir gr√°fico anterior si existe
            if (factoryChart) {
                factoryChart.destroy();
            }

            const colors = [
                'rgba(39, 174, 96, 0.85)',
                'rgba(241, 196, 15, 0.85)',
                'rgba(231, 76, 60, 0.85)'
            ];

            factoryChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: factoryData.map(d => d.factory),
                    datasets: [
                        {
                            label: '% P√©rdida Neta',
                            data: factoryData.map(d => d.tasaPerdida),
                            backgroundColor: factoryData.map((d, i) => colors[i] || colors[2]),
                            borderColor: factoryData.map((d, i) => colors[i]?.replace('0.85', '1') || colors[2]),
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const idx = context.dataIndex;
                                    return [
                                        'P√©rdida: ' + formatPercent(context.parsed.x, 2),
                                        'Cortadas: ' + formatNum(factoryData[idx].cortadas),
                                        'P√©rdida Neta: ' + formatNum(factoryData[idx].perdidaNeta)
                                    ];
                                }
                            }
                        },
                        datalabels: {
                            anchor: 'end',
                            align: 'right',
                            formatter: (value) => formatPercent(value, 1),
                            font: {
                                weight: 'bold',
                                size: 10
                            },
                            color: '#333'
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: '% P√©rdida',
                                font: { size: 10 }
                            },
                            ticks: {
                                font: { size: 9 },
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        },
                        y: {
                            ticks: {
                                font: { size: 10 }
                            }
                        }
                    }
                }
            });
        }

        // --- Nuevo: comparaci√≥n por semanas (barras: Cortadas, Revisada, Real no recuperado) + l√≠nea %Real no recuperado ---
        function getISOWeekNumber(d) {
            // Copy date so don't modify original
            const date = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
            // Set to nearest Thursday: current date + 4 - current day number
            const dayNum = date.getUTCDay() || 7;
            date.setUTCDate(date.getUTCDate() + 4 - dayNum);
            // Year of the Thursday in ISO week date
            const yearStart = new Date(Date.UTC(date.getUTCFullYear(),0,1));
            // Calculate full weeks to nearest Thursday
            const weekNo = Math.ceil((((date - yearStart) / 86400000) + 1)/7);
            return weekNo;
        }

        function calculateWeekComparison(baseAll, prodCorteAll) {
            // Use provided datasets or fall back to global loaded data
            const base = baseAll && baseAll.length ? baseAll : (typeof baseData !== 'undefined' ? baseData : []);
            const prod = prodCorteAll && prodCorteAll.length ? prodCorteAll : (typeof prodCorteData !== 'undefined' ? prodCorteData : []);

            // Determine last week (previous week) and take the last 10 weeks ending in the previous week
            const today = new Date();
            const lastWeekDate = new Date(today);
            lastWeekDate.setDate(today.getDate() - 7); // one week back
            const weeks = [];
            // Build 10 weeks ending at the previous week (lastWeekDate), stepping backwards by 7 days
            for (let i = 9; i >= 0; i--) {
                const d = new Date(lastWeekDate);
                d.setDate(lastWeekDate.getDate() - (i * 7));
                weeks.push(getISOWeekNumber(d));
            }

            const labels = weeks.map(w => `SEM${w}`);

            const cortadas = [];
            const revisadas = [];
            const realNoRecuperado = [];
            const pctRealNoRecuperado = [];

            weeks.forEach(week => {
                const prodRows = prod.filter(r => toNum(r.SEM) == week || toNum(r._week) == week || toNum(r['SEM']) == week);
                const cort = prodRows.reduce((s, r) => s + (toNum(r['CANTIDAD CORTADA']) || toNum(r.CANTIDAD_CORTADA) || toNum(r['CANT. CORTADA']) || 0), 0);
                const rev = prodRows.reduce((s, r) => s + (toNum(r['CANTIDAD REVISADA']) || toNum(r.CANTIDAD_REVISADA) || 0), 0);

                const baseRows = base.filter(r => toNum(r._week) == week || toNum(r.SEM) == week);
                const real = baseRows.reduce((s, r) => s + toNum(r['REAL NO RECUPERADO']), 0);

                cortadas.push(cort);
                revisadas.push(rev);
                realNoRecuperado.push(real);

                const pct = rev > 0 ? (real / rev) * 100 : 0;
                pctRealNoRecuperado.push(pct);
            });

            return {
                labels,
                cortadas,
                revisadas,
                realNoRecuperado,
                pctRealNoRecuperado
            };
        }

        function renderWeekComparisonChart() {
            const canvas = document.getElementById('factoryChart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            if (factoryChart) {
                factoryChart.destroy();
            }

            // Use global data (independent of main filters) to show last 10 weeks
            const weekData = calculateWeekComparison();

            // Determine a 'nice' max for the secondary Y axis based on data
            function niceMaxPercent(value) {
                if (!isFinite(value) || value <= 0) return 1;
                const magnitude = Math.pow(10, Math.floor(Math.log10(value)));
                const scaled = value / magnitude;
                const choices = [1,2,4,5,10];
                for (let i = 0; i < choices.length; i++) {
                    if (scaled <= choices[i]) return choices[i] * magnitude;
                }
                return 10 * magnitude;
            }

            const maxPct = weekData.pctRealNoRecuperado && weekData.pctRealNoRecuperado.length ? Math.max(...weekData.pctRealNoRecuperado) : 0;
            const y1Max = niceMaxPercent(maxPct);

            factoryChart = new Chart(ctx, {
                data: {
                    labels: weekData.labels,
                    datasets: [
                        {
                            type: 'bar',
                            label: 'Pds Corte',
                            data: weekData.cortadas,
                            backgroundColor: 'rgba(54,162,235,0.8)',
                            borderColor: 'rgba(54,162,235,1)',
                            borderWidth: 1,
                            yAxisID: 'y',
                            datalabels: {
                                display: false
                            }
                        },
                        {
                            type: 'bar',
                            label: 'Pds Rev.',
                            data: weekData.revisadas,
                            backgroundColor: 'rgba(75,192,192,0.8)',
                            borderColor: 'rgba(75,192,192,1)',
                            borderWidth: 1,
                            yAxisID: 'y',
                            datalabels: {
                                display: false
                            }
                        },
                        // 'Real no recuperado' barras removidas; s√≥lo se mantiene la l√≠nea de % Real no recuperado
                        {
                            type: 'line',
                            label: '%Pds depuradas',
                            data: weekData.pctRealNoRecuperado,
                            borderColor: 'rgba(155,89,182,1)',
                            backgroundColor: 'rgba(155,89,182,0.1)',
                            yAxisID: 'y1',
                            tension: 0.2,
                            pointRadius: 5,
                            pointBackgroundColor: 'rgba(155,89,182,1)',
                            pointBorderColor: '#fff',
                            pointBorderWidth: 2,
                            datalabels: {
                                display: true,
                                align: 'end',
                                anchor: 'end',
                                formatter: function(value) { return formatPercent(value, 2); },
                                color: '#000',
                                font: { family: 'Calibri, sans-serif', weight: 'bold', size: 14 },
                                offset: -4
                            }
                        }
                    ]
                },
                    options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                            align: 'start',
                            labels: {
                                font: { family: 'Calibri, sans-serif', size: 12 },
                                boxWidth: 16
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.dataset.type === 'line') {
                                        return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + '%';
                                    }
                                    return context.dataset.label + ': ' + formatNum(context.parsed.y);
                                }
                            }
                        }
                    },
                        scales: {
                        x: {
                            title: { display: false },
                            ticks: { font: { size: 10 } }
                        },
                        y: {
                            type: 'linear',
                            position: 'left',
                            title: { display: false },
                            ticks: {
                                font: { size: 10 },
                                callback: function(value) {
                                    const v = Number(value);
                                    if (isNaN(v)) return value;
                                    const abs = Math.abs(v);
                                    if (abs >= 1000) {
                                        // Show without decimal when divisible by 1000, otherwise one decimal
                                        if (v % 1000 === 0) return (v / 1000) + 'k';
                                        return (v / 1000).toFixed(1).replace(/\.0$/, '') + 'k';
                                    }
                                    return v;
                                }
                            }
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            title: { display: false },
                            min: 0,
                            max: y1Max,
                            grid: { drawOnChartArea: false },
                            ticks: { callback: v => v + '%', font: { size: 10 } }
                        }
                    }
                }
            });
        }

        function renderTopOPs(data) {
            const clientsTbody = document.querySelector('#clientsTable tbody');
            const opsTbody = document.querySelector('#opsTable tbody');

            function esc(s) {
                if (s === undefined || s === null) return '';
                return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            }

            // Normalizadores
            function normalizeClientName(name) {
                if (name === undefined || name === null) return '';
                let s = String(name).trim();
                if (!s) return '';
                // Collapsar espacios
                s = s.replace(/\s+/g, ' ').trim();
                // Eliminar sufijo S.A.C. / SAC / S A C (variantes) al final
                s = s.replace(/\s*(?:S\.?A\.?C\.?|SAC)\.?$/i, '').trim();
                return s;
            }

            function sanitizeOP(val) {
                if (val === undefined || val === null) return '';
                let s = String(val).trim();
                if (!s) return '';
                // Mantener solo d√≠gitos
                s = s.replace(/\D/g, '');
                if (!s) return '';
                // Si empieza por '1' eliminar ese primer '1'
                if (s.charAt(0) === '1') s = s.slice(1);
                // Convertir a entero para quitar ceros a la izquierda
                const n = parseInt(s, 10);
                return isNaN(n) ? s : String(n);
            }

            // Agrupar por CLIENTE (desde la hoja base) con normalizaci√≥n
            const clientsMap = {};
            data.forEach(r => {
                const clienteRaw = r.CLIENTE || r.Cliente || '';
                const cliente = normalizeClientName(clienteRaw) || 'N/A';
                const cort = toNum(r['CANT. CORTADA']) || toNum(r['CANTIDAD CORTADA']) || 0;
                const dep = toNum(r['REAL NO RECUPERADO']) || toNum(r.REAL_NO_RECUPERADO) || 0;
                if (!clientsMap[cliente]) clientsMap[cliente] = { cliente, cortadas: 0, dep: 0 };
                clientsMap[cliente].cortadas += cort;
                clientsMap[cliente].dep += dep;
            });

            const clientsArr = Object.values(clientsMap)
                .filter(x => x.cortadas > 0 || x.dep > 0)
                .map(x => ({ ...x, pct: x.cortadas > 0 ? (x.dep / x.cortadas) * 100 : 0 }))
                .sort((a, b) => b.pct - a.pct)
                .slice(0, 10);

            // Agrupar por OP + COLOR (desde la hoja base) con normalizaci√≥n de OP
            const opsMap = {};
            data.forEach(r => {
                const opRaw = (r.OP !== undefined && r.OP !== null) ? r.OP : (r.Op !== undefined ? r.Op : '');
                const op = sanitizeOP(opRaw) || 'N/A';
                const color = r.COLOR || r.Color || 'N/A';
                const cort = toNum(r['CANT. CORTADA']) || toNum(r['CANTIDAD CORTADA']) || 0;
                const dep = toNum(r['REAL NO RECUPERADO']) || toNum(r.REAL_NO_RECUPERADO) || 0;
                const key = `${op}||${color}`;
                if (!opsMap[key]) opsMap[key] = { op, color, cortadas: 0, dep: 0 };
                opsMap[key].cortadas += cort;
                opsMap[key].dep += dep;
            });

            const opsArr = Object.values(opsMap)
                .filter(x => x.cortadas > 0 || x.dep > 0)
                .map(x => ({ ...x, pct: x.cortadas > 0 ? (x.dep / x.cortadas) * 100 : 0 }))
                .sort((a, b) => b.pct - a.pct)
                .slice(0, 10);

            if (!clientsTbody || !opsTbody) {
                const topOpsList = document.getElementById('topOpsList');
                if (topOpsList) topOpsList.innerHTML = '<div style="padding: 12px; color:#999;">No hay datos</div>';
                return;
            }

            clientsTbody.innerHTML = clientsArr.length ? clientsArr.map(c => `
                <tr>
                    <td style="padding:6px;border-bottom:1px solid #f0f0f0;text-align:left;">${esc(c.cliente)}</td>
                    <td style="padding:6px;border-bottom:1px solid #f0f0f0;text-align:right;">${formatNum(c.cortadas)}</td>
                    <td style="padding:6px;border-bottom:1px solid #f0f0f0;text-align:right;">${formatNum(c.dep)}</td>
                    <td style="padding:6px;border-bottom:1px solid #f0f0f0;text-align:right;">${formatPercent(c.pct, 1)}</td>
                </tr>
            `).join('') : '<tr><td colspan="4" style="padding:8px;color:#999;text-align:center;">No hay clientes con p√©rdidas</td></tr>';

            opsTbody.innerHTML = opsArr.length ? opsArr.map(o => {
                // Normalizar HEATHERED a HTR en el color
                const normalizedColor = o.color.replace(/HEATHERED/gi, 'HTR');
                return `
                <tr>
                    <td style="padding:6px;border-bottom:1px solid #f0f0f0;text-align:left;">${esc(o.op)}</td>
                    <td style="padding:6px;border-bottom:1px solid #f0f0f0;text-align:left;">${esc(normalizedColor)}</td>
                    <td style="padding:6px;border-bottom:1px solid #f0f0f0;text-align:right;">${formatNum(o.cortadas)}</td>
                    <td style="padding:6px;border-bottom:1px solid #f0f0f0;text-align:right;">${formatNum(o.dep)}</td>
                    <td style="padding:6px;border-bottom:1px solid #f0f0f0;text-align:right;">${formatPercent(o.pct, 1)}</td>
                </tr>
                `;
            }).join('') : '<tr><td colspan="5" style="padding:8px;color:#999;text-align:center;">No hay OPs con p√©rdidas</td></tr>';
        }

        // ---- Funcionalidad para modal OP/Resumen ----
        function sanitizeOPSimple(val) {
            if (val === undefined || val === null) return '';
            let s = String(val).trim();
            if (!s) return '';
            s = s.replace(/\D/g, '');
            if (!s) return '';
            if (s.charAt(0) === '1') s = s.slice(1);
            const n = parseInt(s, 10);
            return isNaN(n) ? s : String(n);
        }

        function openOpModal() {
            const modal = document.getElementById('opModal');
            const input = document.getElementById('opSearchInput');
            const colorSelect = document.getElementById('colorSelect');
            const head = document.getElementById('opResumenHead');
            const body = document.getElementById('opResumenBody');
            input.value = '';
            colorSelect.innerHTML = '<option value="">(todos)</option>';
            head.innerHTML = '<tr></tr>';
            body.innerHTML = '';
            modal.style.display = 'flex';
            input.focus();
        }

        function closeOpModal() {
            const modal = document.getElementById('opModal');
            modal.style.display = 'none';
            document.getElementById('opResumenBody').innerHTML = '';
        }

        function populateColorOptionsForOp(opValue) {
            const colorSelect = document.getElementById('colorSelect');
            colorSelect.innerHTML = '<option value="">(todos)</option>';
            if (!opValue) return;
            const norm = sanitizeOPSimple(opValue);
            const rows = (baseData || []);
            const colors = new Set();
            rows.forEach(r => {
                const opRaw = r.OP !== undefined && r.OP !== null ? r.OP : (r.Op !== undefined ? r.Op : '');
                const sop = sanitizeOPSimple(opRaw);
                if (sop && sop === norm) {
                    const c = (r.COLOR || r.Color || '').toString().trim();
                    if (c) colors.add(c);
                }
            });
            Array.from(colors).sort().forEach(c => {
                const opt = document.createElement('option');
                opt.value = c;
                opt.textContent = c;
                colorSelect.appendChild(opt);
            });
        }

        function buildOpResumenTable() {
            const opVal = document.getElementById('opSearchInput').value.trim();
            const colorVal = document.getElementById('colorSelect').value;
            const head = document.getElementById('opResumenHead');
            const body = document.getElementById('opResumenBody');
            body.innerHTML = '';
            head.innerHTML = '';

            if (!opVal) {
                head.innerHTML = '<tr><th style="padding:8px;color:#999;text-align:left;">Ingrese una OP</th></tr>';
                return;
            }

            const normOp = sanitizeOPSimple(opVal);
            const rows = (baseData || []).filter(r => {
                const opRaw = r.OP !== undefined && r.OP !== null ? r.OP : (r.Op !== undefined ? r.Op : '');
                const sop = sanitizeOPSimple(opRaw);
                if (!sop || sop !== normOp) return false;
                if (colorVal) {
                    const c = (r.COLOR || r.Color || '').toString().trim();
                    return c === colorVal;
                }
                return true;
            });

            if (!rows.length) {
                head.innerHTML = '<tr><th style="padding:8px;color:#999;text-align:left;">No hay datos para la OP/Color seleccionados</th></tr>';
                lastResumenRows = [];
                lastResumenDefects = [];
                const exportBtnEmpty = document.getElementById('opExportBtn');
                if (exportBtnEmpty) exportBtnEmpty.disabled = true;
                return;
            }

            // Determinar qu√© columnas de defectos est√°n presentes en estas filas
            const presentDefects = defectColumns.filter(col => {
                return rows.some(r => toNum(r[col]) > 0);
            });

            // Agrupar por OP_TELA-PTDA y sumar columnas
            const groupMap = {};
            function sanitizeOpTela(val) {
                if (val === undefined || val === null) return '';
                let s = String(val).trim();
                if (!s) return '';
                s = s.replace(/\D/g, '');
                if (!s) return '';
                if (s.charAt(0) === '1') s = s.slice(1);
                const n = parseInt(s, 10);
                return isNaN(n) ? s : String(n);
            }

            rows.forEach(r => {
                const cliente = (r.CLIENTE || r.Cliente || '').toString().trim();
                const op_raw = r.OP || r.Op || '';
                const color = (r.COLOR || r.Color || '').toString().trim();
                const op_tela_raw = r.OP_TELA || r['OP_TELA'] || r['OP TELA'] || '';
                const ptda_raw = (r.PTDA !== undefined && r.PTDA !== null) ? r.PTDA : (r.PTDS !== undefined ? r.PTDS : '');

                const op_tela_clean = sanitizeOpTela(op_tela_raw);
                const ptda_clean = (ptda_raw === undefined || ptda_raw === null || ptda_raw === '') ? '' : String(parseInt(ptda_raw, 10));
                const key = ptda_clean ? `${op_tela_clean}-${ptda_clean}` : op_tela_clean;

                if (!groupMap[key]) {
                    groupMap[key] = {
                        CLIENTES: new Set(),
                        OP: sanitizeOPSimple(op_raw),
                        COLORS: new Set(),
                        OP_TELA: op_tela_clean,
                        PTDA: ptda_clean,
                        PDS_CORTE: 0,
                        PDS_DEP: 0,
                        DEFECTS: {},
                    };
                    presentDefects.forEach(col => { groupMap[key].DEFECTS[col] = 0; });
                }

                const g = groupMap[key];
                if (cliente) g.CLIENTES.add(cliente);
                if (color) g.COLORS.add(color);
                g.PDS_CORTE += toNum(r['CANT. CORTADA']) || toNum(r['CANTIDAD CORTADA']) || 0;
                g.PDS_DEP += toNum(r['REAL NO RECUPERADO']) || toNum(r.REAL_NO_RECUPERADO) || 0;
                presentDefects.forEach(col => {
                    g.DEFECTS[col] += toNum(r[col]);
                });
            });

            // Construir filas agregadas
            const aggregated = Object.keys(groupMap).map(k => {
                const g = groupMap[k];
                const clienteArr = Array.from(g.CLIENTES);
                let clienteLabel = '';
                if (clienteArr.length === 0) clienteLabel = '';
                else if (clienteArr.length === 1) clienteLabel = clienteArr[0];
                else if (clienteArr.length <= 3) clienteLabel = clienteArr.join(' / ');
                else clienteLabel = 'VARIOS';

                const colorArr = Array.from(g.COLORS);
                const colorLabel = colorArr.length === 1 ? colorArr[0] : (colorArr.length === 0 ? '' : 'VARIOS');

                // calcular % depurado como (PDS_DEP / PDS_CORTE) * 100
                const pct = g.PDS_CORTE > 0 ? (g.PDS_DEP / g.PDS_CORTE) * 100 : 0;

                // total de defectos
                let totalDef = 0;
                const defectValues = {};
                presentDefects.forEach(col => {
                    const v = g.DEFECTS[col] || 0;
                    defectValues[col] = v;
                    totalDef += v;
                });

                return Object.assign({
                    CLIENTE: clienteLabel,
                    OP: g.OP,
                    COLOR: colorLabel,
                    OP_TELA_PTDA: k,
                    PDS_CORTE: g.PDS_CORTE,
                    PDS_DEPURADAS: g.PDS_DEP,
                    PCTDEP: pct,
                    TOTAL_PZAS: totalDef
                }, defectValues);
            });

            // Ordenar por %DEPURADO descendente
            aggregated.sort((a,b) => (b.PCTDEP || 0) - (a.PCTDEP || 0));

            // Guardar estado agregado para exportar
            lastResumenRows = aggregated.slice();
            lastResumenDefects = presentDefects.slice();

            const exportBtn = document.getElementById('opExportBtn');
            if (exportBtn) exportBtn.disabled = false;

            // Construir encabezados exactos solicitados (con texto final solicitado)
            const headers = [
                'CLIENTE',
                'OP', // la OP de la b√∫squeda
                'COLOR', // el color de la b√∫squeda
                'OP_TELA-PTDA',
                'PDS CORTE',
                'PDS DEPURADAS',
                '%DEPURADO'
            ];

            const trh = document.createElement('tr');
            // a√±adir encabezados base
            headers.forEach(h => {
                const th = document.createElement('th');
                th.textContent = h;
                th.title = h;
                th.style.padding = '6px';
                th.style.borderBottom = '1px solid #ddd';
                th.style.textAlign = (['CLIENTE','OP','COLOR','OP_TELA','PTDA'].includes(h)) ? 'left' : 'right';
                trh.appendChild(th);
            });

            // a√±adir encabezados de defectos (solo los presentes)
            presentDefects.forEach(col => {
                const th = document.createElement('th');
                th.textContent = col; // usar nombre completo de columna
                th.title = col;
                th.style.padding = '6px';
                th.style.borderBottom = '1px solid #ddd';
                th.style.textAlign = 'right';
                trh.appendChild(th);
            });

            // columna TOTAL PZAS
            const thTotal = document.createElement('th');
            thTotal.textContent = 'TOTAL PZAS';
            thTotal.title = 'TOTAL PZAS';
            thTotal.style.padding = '6px';
            thTotal.style.borderBottom = '1px solid #ddd';
            thTotal.style.textAlign = 'right';
            trh.appendChild(thTotal);

            head.appendChild(trh);

            // Filas: usar datos agregados (lastResumenRows) si existen, sino usar 'aggregated'
            const rowsToRender = (lastResumenRows && lastResumenRows.length) ? lastResumenRows : aggregated;
            rowsToRender.forEach(r => {
                const tr = document.createElement('tr');

                const cliente = r.CLIENTE || r.Cliente || r.CLIENTES || '';
                const op_clean = r.OP || r.Op || '';
                const color = r.COLOR || r.Color || r.COLORS || '';
                const combined = r.OP_TELA_PTDA || r['OP_TELA-PTDA'] || r.OP_TELA_PTDA || '';

                const cols = [cliente, op_clean, color, combined];
                cols.forEach(v => {
                    const td = document.createElement('td');
                    td.style.padding = '6px';
                    td.style.borderBottom = '1px solid #f5f5f5';
                    td.style.textAlign = 'left';
                    td.textContent = (v === undefined || v === null) ? '' : String(v);
                    tr.appendChild(td);
                });

                const pdsC = toNum(r.PDS_CORTE || r.PDS_CORTE || r.PDS_CORTE);
                const pdsD = toNum(r.PDS_DEPURADAS || r.PDS_DEP || r.PDS_DEPURADAS);
                const pct = r.PCTDEP !== undefined ? r.PCTDEP : (pdsC > 0 ? (pdsD / pdsC) * 100 : 0);

                const tdC = document.createElement('td'); tdC.textContent = formatNum(pdsC); tdC.style.textAlign = 'right'; tr.appendChild(tdC);
                const tdD = document.createElement('td'); tdD.textContent = formatNum(pdsD); tdD.style.textAlign = 'right'; tr.appendChild(tdD);
                const tdPct = document.createElement('td'); tdPct.textContent = formatPercent(pct,2); tdPct.style.textAlign = 'right'; tr.appendChild(tdPct);

                // Defectos
                let totalDef = 0;
                presentDefects.forEach(col => {
                    const v = toNum(r[col]) || toNum((r.DEFECTS && r.DEFECTS[col]) || 0);
                    totalDef += v;
                    const td = document.createElement('td'); td.textContent = formatNum(v); td.style.textAlign = 'right'; td.style.padding = '6px'; td.style.borderBottom = '1px solid #f5f5f5'; tr.appendChild(td);
                });

                const tdTotal = document.createElement('td'); tdTotal.textContent = formatNum(totalDef || r.TOTAL_PZAS || 0); tdTotal.style.textAlign = 'right'; tdTotal.style.padding = '6px'; tdTotal.style.borderBottom = '1px solid #f5f5f5'; tr.appendChild(tdTotal);

                body.appendChild(tr);
            });

            // Calcular y mostrar totales (PDS CORTE, PDS DEPURADAS, %DEPURADO general)
            const totalPdsCorte = rowsToRender.reduce((s, rr) => s + (toNum(rr.PDS_CORTE || rr.PDS_CORTE || rr.PDS_CORTE) || 0), 0);
            const totalPdsDep = rowsToRender.reduce((s, rr) => s + (toNum(rr.PDS_DEPURADAS || rr.PDS_DEP || rr.PDS_DEPURADAS) || 0), 0);
            const overallPct = totalPdsCorte > 0 ? (totalPdsDep / totalPdsCorte) * 100 : 0;
            const totalsEl = document.getElementById('opResumenTotals');
            const totalsTextEl = document.getElementById('opResumenTotalsText');
            if (totalsTextEl && totalsEl) {
                totalsTextEl.innerHTML = `TOTAL PDS REVISADAS&nbsp;&nbsp;${formatNum(totalPdsCorte)} pds - TOTAL PDS DEPURADAS&nbsp;&nbsp;${formatNum(totalPdsDep)} pds - %DEPURADO&nbsp;&nbsp;${formatPercent(overallPct,2)}`;
                totalsEl.style.display = '';
            }
        }

        // Event bindings for the modal
        document.addEventListener('click', function(e) {
            const opBtn = document.getElementById('opButton');
            if (opBtn && e.target === opBtn) openOpModal();
        });

        document.addEventListener('DOMContentLoaded', function() {
            const opBtn = document.getElementById('opButton');
            if (opBtn) opBtn.addEventListener('click', openOpModal);
            const closeBtn = document.getElementById('opModalClose');
            if (closeBtn) closeBtn.addEventListener('click', closeOpModal);
            const modal = document.getElementById('opModal');
            if (modal) modal.addEventListener('click', function(ev) { if (ev.target === modal) closeOpModal(); });

            const input = document.getElementById('opSearchInput');
            if (input) {
                let t;
                input.addEventListener('input', function() {
                    clearTimeout(t);
                    t = setTimeout(() => populateColorOptionsForOp(input.value), 250);
                });
                input.addEventListener('keydown', function(ev) {
                    if (ev.key === 'Enter') {
                        ev.preventDefault();
                        // Al presionar Enter se cargan los colores desde la hoja base y se enfoca el select
                        populateColorOptionsForOp(input.value);
                        const sel = document.getElementById('colorSelect');
                        if (sel) sel.focus();
                    }
                });
            }

            const resumenBtn = document.getElementById('opResumenBtn');
            if (resumenBtn) resumenBtn.addEventListener('click', buildOpResumenTable);

            const exportBtn = document.getElementById('opExportBtn');
            if (exportBtn) {
                exportBtn.disabled = true;
                exportBtn.addEventListener('click', function() {
                    try {
                        exportOpResumenExcel();
                    } catch (e) {
                        console.error('Error exportando Excel:', e);
                    }
                });
            }

            // Event listeners para modal TELA
            const telaBtn = document.getElementById('telaButton');
            if (telaBtn) telaBtn.addEventListener('click', openTelaModal);
            const telaClose = document.getElementById('telaModalClose');
            if (telaClose) telaClose.addEventListener('click', closeTelaModal);
            const telaModalEl = document.getElementById('telaModal');
            if (telaModalEl) telaModalEl.addEventListener('click', function(ev) { if (ev.target === telaModalEl) closeTelaModal(); });

            const telaPeriodSel = document.getElementById('telaPeriodTypeSelect');
            if (telaPeriodSel) telaPeriodSel.addEventListener('change', function() { toggleTelaPeriodFilter(); });
            const telaRefresh = document.getElementById('telaRefreshBtn');
            if (telaRefresh) telaRefresh.addEventListener('click', buildTelaResumenTable);
            const telaExport = document.getElementById('telaExportBtn');
            if (telaExport) telaExport.addEventListener('click', exportTelaResumenExcel);

            // Event listeners para men√∫ contextual de defectos
            const contextMenuDetail = document.getElementById('contextMenuDetail');
            const contextMenuTrend = document.getElementById('contextMenuTrend');
            
            if (contextMenuDetail) {
                contextMenuDetail.addEventListener('click', function() {
                    closeContextMenu();
                    if (currentDefectForMenu) {
                        const rows = getFilteredData().filter(r => toNum(r[currentDefectForMenu]) > 0);
                        showDefectModal(currentDefectForMenu, rows);
                    }
                });
            }
            
            if (contextMenuTrend) {
                contextMenuTrend.addEventListener('click', function() {
                    closeContextMenu();
                    if (currentDefectForMenu) {
                        showDefectTrendModal(currentDefectForMenu);
                    }
                });
            }

            // Event listener para bot√≥n de Acciones (Pareto)
            const btnAcciones = document.getElementById('btnAcciones');
            if (btnAcciones) {
                btnAcciones.addEventListener('click', function() { showAccionesModal(); });
            }

            // Event listener para bot√≥n Accion dentro del modal Trend
            const trendAccBtn = document.getElementById('trendModalAccion');
            if (trendAccBtn) {
                trendAccBtn.addEventListener('click', function() {
                    const defect = window.currentTrendDefect || null;
                    if (!defect) {
                        alert('No hay defecto seleccionado');
                        return;
                    }
                    showAccionesForDefect(defect);
                });
            }

            const accionesModalClose = document.getElementById('accionesModalClose');
            if (accionesModalClose) {
                accionesModalClose.addEventListener('click', closeAccionesModal);
            }

            const accionesModalEl = document.getElementById('accionesModal');
            if (accionesModalEl) {
                accionesModalEl.addEventListener('click', function(ev) {
                    if (ev.target === accionesModalEl) closeAccionesModal();
                });
            }
        });

        function showAccionesModal(rows, titleSuffix) {
            const modal = document.getElementById('accionesModal');
            const thead = document.getElementById('accionesTableHead');
            const tbody = document.getElementById('accionesTableBody');

            // Limpiar tabla
            thead.innerHTML = '';
            tbody.innerHTML = '';

            const data = (rows && rows.length) ? rows : (accionesData || []);

            // Ajustar t√≠tulo del modal si se pasa sufijo
            const titleEl = modal.querySelector('.modal-title');
            if (titleEl) {
                titleEl.textContent = titleSuffix ? `üìã Tabla de Acciones - ${titleSuffix}` : 'üìã Tabla de Acciones';
            }

            if (!data || data.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" style="text-align:center;padding:20px;">No hay datos de acciones disponibles</td></tr>';
                modal.style.display = 'flex';
                return;
            }

            // Columnas espec√≠ficas con anchos definidos
            const columnConfig = [
                { key: 'DEFECTO', label: 'DEFECTO', width: '20%' },
                { key: 'ACCIONES', label: 'ACCIONES', width: '60%' },
                { key: 'RESPONSABLES', label: 'RESPONSABLES', width: '10%' },
                { key: 'FECHA FIN', label: 'FECHA FIN', width: '10%' }
            ];
            
            // Crear encabezados
            const headerRow = document.createElement('tr');
            columnConfig.forEach(col => {
                const th = document.createElement('th');
                th.textContent = col.label;
                th.style.background = 'rgb(155,194,230)';
                th.style.color = '#000';
                th.style.fontWeight = '700';
                th.style.padding = '8px';
                th.style.border = '1px solid #ddd';
                th.style.width = col.width;
                th.style.whiteSpace = 'normal';
                th.style.wordWrap = 'break-word';
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);

            // Crear filas de datos
            data.forEach((row, index) => {
                const tr = document.createElement('tr');
                if (index % 2 === 1) {
                    tr.style.backgroundColor = '#f9f9f9';
                }
                
                columnConfig.forEach(col => {
                    const td = document.createElement('td');
                    const value = row[col.key] || row[col.label] || '';
                    td.textContent = value !== undefined && value !== null ? String(value) : '';
                    td.style.padding = '6px 8px';
                    td.style.border = '1px solid #f0f0f0';
                    td.style.width = col.width;
                    td.style.whiteSpace = 'normal';
                    td.style.wordWrap = 'break-word';
                    td.style.verticalAlign = 'top';
                    tr.appendChild(td);
                });
                
                tbody.appendChild(tr);
            });

            // Mostrar modal
            modal.style.display = 'flex';
        }

        function closeAccionesModal() {
            const modal = document.getElementById('accionesModal');
            modal.style.display = 'none';
        }

        function showAccionesForDefect(defectName) {
            if (!defectName) {
                showAccionesModal();
                return;
            }
            // Determinar la clave de columna que contiene la palabra 'DEFECT'
            let defectKey = null;
            if (accionesData && accionesData.length > 0) {
                const keys = Object.keys(accionesData[0]);
                for (const k of keys) {
                    if (k && k.toString().toUpperCase().includes('DEFECT')) { defectKey = k; break; }
                }
            }

            if (!defectKey) defectKey = 'DEFECTO';

            const filtered = (accionesData || []).filter(r => {
                const v = r[defectKey] || r['DEFECTO'] || r['Defecto'] || '';
                return String(v).toUpperCase().trim().includes(String(defectName).toUpperCase().trim());
            });

            showAccionesModal(filtered, defectName);
        }

        function exportOpResumenExcel() {
            if (!window.XLSX) {
                alert('La librer√≠a de exportaci√≥n no est√° disponible.');
                return;
            }

            if (!lastResumenRows || lastResumenRows.length === 0) {
                alert('No hay datos para exportar.');
                return;
            }

            // Construir array de arrays (AOA) para SheetJS
            const baseHeaders = ['CLIENTE','OP','COLOR','OP_TELA-PTDA','PDS CORTE','PDS DEPURADAS','%DEPURADO'];
            const headers = baseHeaders.concat(lastResumenDefects || []).concat(['TOTAL PZAS']);

            const aoa = [];
            aoa.push(headers);

            lastResumenRows.forEach(r => {
                const cliente = r.CLIENTE || r.Cliente || r.CLIENTES || '';
                const op_raw = r.OP || r.Op || '';
                const color = r.COLOR || r.Color || r.COLORS || '';

                // Determine combined OP_TELA-PTDA
                const combined = r.OP_TELA_PTDA || r['OP_TELA-PTDA'] || '';

                // Use aggregated fields if present
                const cantCortada = (r.PDS_CORTE !== undefined) ? toNum(r.PDS_CORTE) : (toNum(r['CANT. CORTADA']) || toNum(r['CANTIDAD CORTADA']) || 0);
                const realNoRec = (r.PDS_DEPURADAS !== undefined) ? toNum(r.PDS_DEPURADAS) : (toNum(r['REAL NO RECUPERADO']) || toNum(r.REAL_NO_RECUPERADO) || 0);
                const pctDep = (r.PCTDEP !== undefined) ? r.PCTDEP : (cantCortada > 0 ? (realNoRec / cantCortada) * 100 : 0);

                const rowArr = [];
                rowArr.push(cliente);
                rowArr.push(sanitizeOPSimple(op_raw));
                rowArr.push(color);
                rowArr.push(combined);
                rowArr.push(cantCortada);
                rowArr.push(realNoRec);
                // Store percent as fraction for Excel (e.g., 0.3459) so we can apply % format
                rowArr.push(pctDep / 100);

                let totalDef = 0;
                (lastResumenDefects || []).forEach(col => {
                    const v = toNum(r[col]) || toNum((r.DEFECTS && r.DEFECTS[col]) || 0);
                    totalDef += v;
                    rowArr.push(v);
                });

                rowArr.push(totalDef);
                aoa.push(rowArr);
            });

            // Crear workbook y descargar
            const ws = XLSX.utils.aoa_to_sheet(aoa);
            // Aplicar formato de porcentaje a la columna %DEPURADO (buscar √≠ndice)
            const pctColIndex = headers.indexOf('%DEPURADO');
            if (pctColIndex >= 0) {
                // funci√≥n para convertir √≠ndice 0->A, 1->B, ...
                function colLetter(col) {
                    let s = '';
                    let n = col;
                    while (n >= 0) {
                        s = String.fromCharCode((n % 26) + 65) + s;
                        n = Math.floor(n / 26) - 1;
                    }
                    return s;
                }
                const col = colLetter(pctColIndex);
                for (let r = 2; r <= aoa.length; r++) {
                    const addr = col + r; // e.g., G2
                    if (ws[addr]) {
                        // asegurar tipo num√©rico y formato porcentaje con 2 decimales
                        ws[addr].t = 'n';
                        // ws[addr].v is already numeric (fraction)
                        ws[addr].z = '0.00%';
                    }
                }
            }
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Resumen_OP');
            const opVal = document.getElementById('opSearchInput') ? document.getElementById('opSearchInput').value.trim() : '';
            const colorVal = document.getElementById('colorSelect') ? document.getElementById('colorSelect').value : '';
            const stamp = (new Date()).toISOString().slice(0,19).replace(/[:T]/g,'-');
            const fname = `Resumen_OP_${opVal || 'ALL'}_${colorVal || 'ALL'}_${stamp}.xlsx`;
            XLSX.writeFile(wb, fname);
        }

        // ---- Nuevo: modal y funciones para Resumen por TELA ----
        function openTelaModal() {
            const modal = document.getElementById('telaModal');
            if (!modal) return;
            // Copiar opciones de los selects principales
            const srcYear = document.getElementById('yearSelect');
            const srcWeek = document.getElementById('weekSelect');
            const srcMonth = document.getElementById('monthSelect');
            const srcCliente = document.getElementById('clienteSelect');

            const ty = document.getElementById('telaYearSelect');
            const tw = document.getElementById('telaWeekSelect');
            const tm = document.getElementById('telaMonthSelect');
            const tc = document.getElementById('telaClienteSelect');
            const tPeriod = document.getElementById('telaPeriodTypeSelect');

            if (srcYear && ty) ty.innerHTML = srcYear.innerHTML;
            if (srcWeek && tw) tw.innerHTML = srcWeek.innerHTML;
            if (srcMonth && tm) tm.innerHTML = srcMonth.innerHTML;
            if (srcCliente && tc) tc.innerHTML = srcCliente.innerHTML;

            // Valores por defecto: usar filtros actuales de la p√°gina si existen
            try {
                const mainYear = document.getElementById('yearSelect').value;
                const mainPeriod = document.getElementById('periodTypeSelect').value || 'week';
                const mainWeek = document.getElementById('weekSelect').value;
                if (ty) ty.value = mainYear || ty.value || '';
                if (tPeriod) tPeriod.value = mainPeriod || 'week';
                toggleTelaPeriodFilter();
                if (document.getElementById('telaPeriodTypeSelect').value === 'week') {
                    if (tw) tw.value = mainWeek || tw.value || '';
                } else {
                    if (tm) tm.value = document.getElementById('monthSelect').value || tm.value || '';
                }
                const mainCliente = document.getElementById('clienteSelect').value;
                if (tc) tc.value = mainCliente || '';
            } catch (e) {
                console.warn('No se pudieron sincronizar valores por defecto del modal TELA:', e);
            }

            // Mostrar modal
            modal.style.display = 'flex';
            // Construir tabla inicial
            buildTelaResumenTable();
        }

        function closeTelaModal() {
            const modal = document.getElementById('telaModal');
            if (!modal) return;
            modal.style.display = 'none';
            document.getElementById('telaResumenBody').innerHTML = '';
        }

        function toggleTelaPeriodFilter() {
            const p = document.getElementById('telaPeriodTypeSelect').value;
            const weekG = document.getElementById('telaWeekGroup');
            const monthG = document.getElementById('telaMonthGroup');
            if (p === 'week') {
                weekG.style.display = '';
                monthG.style.display = 'none';
            } else {
                weekG.style.display = 'none';
                monthG.style.display = '';
            }
        }

        function buildTelaResumenTable() {
            const year = document.getElementById('telaYearSelect').value;
            const periodType = document.getElementById('telaPeriodTypeSelect').value;
            const week = document.getElementById('telaWeekSelect').value;
            const month = document.getElementById('telaMonthSelect').value;
            const cliente = document.getElementById('telaClienteSelect').value;

            // Filtrar baseData seg√∫n los filtros seleccionados
            let rows = (baseData || []).slice();
            if (year) rows = rows.filter(r => (r._year && String(r._year) === String(year)));
            if (periodType === 'week' && week) rows = rows.filter(r => (r._week && String(r._week) === String(week)) || (r.SEM && String(r.SEM) === String(week)) );
            if (periodType === 'month' && month) rows = rows.filter(r => (r._month && String(r._month) === String(month)) || (r.MES && String(r.MES) === String(month)) );
            if (cliente) rows = rows.filter(r => (r.CLIENTE === cliente));

            const grouped = {};
            rows.forEach(r => {
                const tela = (r.TELA !== undefined && r.TELA !== null) ? String(r.TELA).trim() : '';
                // Normalizar a may√∫sculas y eliminar comillas para agrupar telas consistentemente
                const key = tela ? tela.toUpperCase().replace(/"/g, '') : '(SIN TELA)';
                if (!grouped[key]) grouped[key] = { TELA: key, CLIENTES: new Set(), CORTADA: 0, REAL_NO_RECUPERADO: 0, PZAS_DEFECT: 0 };
                const clienteRaw = (r.CLIENTE || r.Cliente || '').toString().trim();
                if (clienteRaw) grouped[key].CLIENTES.add(clienteRaw);
                grouped[key].CORTADA += toNum(r['CANT. CORTADA']) || toNum(r['CANTIDAD CORTADA']) || toNum(r['CANT']) || 0;
                grouped[key].REAL_NO_RECUPERADO += toNum(r['REAL NO RECUPERADO']) || toNum(r.REAL_NO_RECUPERADO) || 0;
                // sumar todos los defectos detectados
                (defectColumns || []).forEach(col => {
                    grouped[key].PZAS_DEFECT += toNum(r[col]);
                });
            });

            const arr = Object.values(grouped).map(g => {
                const pct = g.CORTADA > 0 ? (g.REAL_NO_RECUPERADO / g.CORTADA) * 100 : 0;
                // Resolver etiqueta de cliente
                const clienteArr = Array.from(g.CLIENTES || []).filter(x => x && x.trim());
                let clienteLabel = '';
                if (clienteArr.length === 0) clienteLabel = '';
                else if (clienteArr.length === 1) clienteLabel = clienteArr[0];
                else if (clienteArr.length <= 3) clienteLabel = clienteArr.join(' / ');
                else clienteLabel = 'VARIOS';
                return Object.assign({}, g, { PCTDEP: pct, CLIENTE: clienteLabel });
            });

            // Ordenar por %DEPURADO descendente
            arr.sort((a,b) => (b.PCTDEP || 0) - (a.PCTDEP || 0));

            const head = document.getElementById('telaResumenHead');
            const body = document.getElementById('telaResumenBody');
            head.innerHTML = '';
            body.innerHTML = '';

            // Encabezados solicitados (renombrados) y anchos fijos
            const headers = ['CLIENTE','TELA', 'PDS REVISADAS', 'PDS DEPURADAS', '%DEPURADO', 'PZAS DEPURADAS'];
            // No fijar ancho para CLIENTE (permitir tama√±o necesario). Anchos para las dem√°s columnas:
            const colWidths = {
                'CLIENTE': 'auto',
                'TELA': '45%',
                'PDS REVISADAS': '11%',
                'PDS DEPURADAS': '11%',
                '%DEPURADO': '11%',
                'PZAS DEPURADAS': '11%'
            };
            const trh = document.createElement('tr');
            headers.forEach(h => {
                const th = document.createElement('th');
                th.textContent = h;
                th.style.padding = '4px';
                th.style.borderBottom = '1px solid #ddd';
                // Alinear izquierda para CLIENTE y TELA, derecha para el resto
                th.style.textAlign = (h === 'CLIENTE' || h === 'TELA') ? 'left' : 'right';
                // Garantizar un ancho m√≠nimo para la columna CLIENTE
                if (h === 'CLIENTE') {
                    th.style.whiteSpace = 'nowrap';
                }
                if (colWidths[h] && colWidths[h] !== 'auto') th.style.width = colWidths[h];
                trh.appendChild(th);
            });
            head.appendChild(trh);

            // Render filas
            arr.forEach(row => {
                const tr = document.createElement('tr');
                const tdCliente = document.createElement('td');
                tdCliente.textContent = row.CLIENTE || '';
                tdCliente.style.textAlign = 'left';
                tdCliente.style.padding = '4px';
                // ajustar ancho a contenido para CLIENTE
                tdCliente.style.whiteSpace = 'nowrap';
                tr.appendChild(tdCliente);
                const tdTela = document.createElement('td');
                tdTela.textContent = row.TELA;
                tdTela.style.textAlign = 'left';
                tdTela.style.padding = '4px';
                tdTela.style.cursor = 'pointer';
                tdTela.style.color = '#2a5298';
                tdTela.style.textDecoration = 'underline';
                tdTela.title = 'Click para ver detalle';
                tdTela.addEventListener('click', function() {
                    showTelaDetail(row.TELA);
                });
                if (colWidths['TELA']) tdTela.style.width = colWidths['TELA'];
                tr.appendChild(tdTela);
                const tdCort = document.createElement('td'); tdCort.textContent = formatNum(row.CORTADA); tdCort.style.textAlign = 'right'; tdCort.style.padding = '4px'; if (colWidths['PDS REVISADAS']) tdCort.style.width = colWidths['PDS REVISADAS']; tr.appendChild(tdCort);
                const tdReal = document.createElement('td'); tdReal.textContent = formatNum(row.REAL_NO_RECUPERADO); tdReal.style.textAlign = 'right'; tdReal.style.padding = '4px'; if (colWidths['PDS DEPURADAS']) tdReal.style.width = colWidths['PDS DEPURADAS']; tr.appendChild(tdReal);
                const tdPct = document.createElement('td'); tdPct.textContent = formatPercent(row.PCTDEP, 2); tdPct.style.textAlign = 'right'; tdPct.style.padding = '4px'; if (colWidths['%DEPURADO']) tdPct.style.width = colWidths['%DEPURADO']; tr.appendChild(tdPct);
                const tdPz = document.createElement('td'); tdPz.textContent = formatNum(row.PZAS_DEFECT); tdPz.style.textAlign = 'right'; tdPz.style.padding = '4px'; if (colWidths['PZAS DEPURADAS']) tdPz.style.width = colWidths['PZAS DEPURADAS']; tr.appendChild(tdPz);
                body.appendChild(tr);
            });

            // Totales
            const totalCort = arr.reduce((s, r) => s + (toNum(r.CORTADA) || 0), 0);
            const totalReal = arr.reduce((s, r) => s + (toNum(r.REAL_NO_RECUPERADO) || 0), 0);
            const totalPz = arr.reduce((s, r) => s + (toNum(r.PZAS_DEFECT) || 0), 0);
            const overallPct = totalCort > 0 ? (totalReal / totalCort) * 100 : 0;
            const totalsEl = document.getElementById('telaResumenTotals');
            const totalsTextEl = document.getElementById('telaResumenTotalsText');
            if (totalsTextEl && totalsEl) {
                totalsTextEl.innerHTML = `TOTAL PDS REVISADAS&nbsp;&nbsp;${formatNum(totalCort)} - TOTAL PDS DEPURADAS&nbsp;&nbsp;${formatNum(totalReal)} - %DEPURADO&nbsp;&nbsp;${formatPercent(overallPct,2)} - PZAS DEPURADAS&nbsp;&nbsp;${formatNum(totalPz)}`;
                totalsEl.style.display = '';
            }

            // Habilitar export si hay datos
            const exp = document.getElementById('telaExportBtn');
            if (exp) exp.disabled = !(arr && arr.length > 0 && window.XLSX);

            // Guardar estado para posible export
            window._lastTelaResumen = { rows: arr, filters: { year, periodType, week, month, cliente } };
        }

        function exportTelaResumenExcel() {
            if (!window.XLSX) {
                alert('La librer√≠a de exportaci√≥n no est√° disponible.');
                return;
            }
            const st = window._lastTelaResumen;
            if (!st || !st.rows || st.rows.length === 0) {
                alert('No hay datos para exportar.');
                return;
            }
            const headers = ['CLIENTE','TELA','PDS REVISADAS','PDS DEPURADAS','%DEPURADO','PZAS DEPURADAS'];
            const aoa = [headers];
            st.rows.forEach(r => {
                aoa.push([r.CLIENTE || '', r.TELA, toNum(r.CORTADA), toNum(r.REAL_NO_RECUPERADO), (r.PCTDEP/100), toNum(r.PZAS_DEFECT)]);
            });
            const ws = XLSX.utils.aoa_to_sheet(aoa);
            // format % column (index 3)
            function colLetter(col) { let s = ''; let n = col; while (n >= 0) { s = String.fromCharCode((n % 26) + 65) + s; n = Math.floor(n / 26) - 1; } return s; }
            const pctCol = colLetter(3);
            for (let r = 2; r <= aoa.length; r++) {
                const addr = pctCol + r;
                if (ws[addr]) { ws[addr].t = 'n'; ws[addr].z = '0.00%'; }
            }
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Resumen_TELA');
            const stamp = (new Date()).toISOString().slice(0,19).replace(/[:T]/g,'-');
            XLSX.writeFile(wb, `Resumen_TELA_${stamp}.xlsx`);
        }

        function renderCharts(data, prodCorteFiltered) {
            const paretoData = calculatePareto(data);
            renderParetoChart(paretoData);

            // Mostrar comparaci√≥n por semanas en el √°rea 'Comparativa Factory Code'
            // Este gr√°fico es independiente de los filtros principales y siempre muestra
            // las √∫ltimas 10 semanas desde la fecha actual.
            renderWeekComparisonChart();

            renderTopOPs(data);
        }

        function applyFilters() {
            currentFilters.year = document.getElementById('yearSelect').value;
            currentFilters.periodType = document.getElementById('periodTypeSelect').value;
            currentFilters.month = document.getElementById('monthSelect').value;
            currentFilters.week = document.getElementById('weekSelect').value;
            currentFilters.cliente = document.getElementById('clienteSelect').value;

            console.log('========== APLICANDO FILTROS ==========');
            console.log('Filtros activos:', currentFilters);

            const filteredData = getFilteredData();
            const filteredProdCorte = getFilteredProdCorteData();

            if (filteredData.length === 0) {
                updateStatus('No hay datos', 'error');
                return;
            }

            const kpis = calculateKPIs(filteredData, filteredProdCorte);
            renderKPIs(kpis);
            renderCharts(filteredData, filteredProdCorte);
            
            let filterText = '';
            if (currentFilters.year) filterText += `${currentFilters.year} `;
            if (currentFilters.periodType === 'month' && currentFilters.month) {
                const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
                filterText += `${monthNames[currentFilters.month - 1]} `;
            }
            if (currentFilters.periodType === 'week' && currentFilters.week) filterText += `S${currentFilters.week} `;
            if (currentFilters.cliente) filterText += `${currentFilters.cliente} `;
            
            updateStatus('‚úì Datos', 'success');
        }

        async function init() {
            try {
                updateStatus('Cargando...', 'loading');

                // Cargar las tres hojas en paralelo
                [baseData, prodCorteData, accionesData] = await Promise.all([
                    loadSheetJSONP(SHEET_ID, BASE_SHEET),
                    loadSheetJSONP(SHEET_ID, PROD_CORTE_SHEET),
                    loadSheetJSONP(SHEET_ID, ACCIONES_SHEET).catch(err => {
                        console.warn('No se pudo cargar la hoja de acciones:', err);
                        return [];
                    })
                ]);

                if (baseData.length === 0) {
                    updateStatus('Sin datos', 'error');
                    return;
                }

                console.log('Datos cargados - base:', baseData.length, 'prod_corte:', prodCorteData.length, 'acciones:', accionesData.length);

                defectColumns = detectDefectColumns(baseData);
                
                // Log para verificar nombres de columnas exactos
                if (baseData.length > 0) {
                    const firstRow = baseData[0];
                    const allColumns = Object.keys(firstRow);
                    console.log('üìã Columnas disponibles en la primera fila:', allColumns);
                    
                    // Buscar columnas que contengan "DEPURADO" o "DEPL"
                    const depColumns = allColumns.filter(col => 
                        col.toUpperCase().includes('DEPURADO') || 
                        col.toUpperCase().includes('DEPL')
                    );
                    console.log('üìä Columnas relacionadas con DEPURADO:', depColumns);
                    
                    // Mostrar valor de ejemplo
                    depColumns.forEach(col => {
                        console.log(`  - "${col}": ${firstRow[col]}`);
                    });
                }
                
                if (defectColumns.length === 0) {
                    console.warn('No se detectaron columnas de defectos');
                }

                populateFilters();
                
                // Establecer filtros por defecto
                // 1. A√±o actual
                const currentYear = new Date().getFullYear();
                const yearSelect = document.getElementById('yearSelect');
                for (let i = 0; i < yearSelect.options.length; i++) {
                    if (yearSelect.options[i].value == currentYear) {
                        yearSelect.selectedIndex = i;
                        currentFilters.year = yearSelect.value;
                        break;
                    }
                }
                // Si no existe el a√±o actual, seleccionar el m√°s reciente
                if (!currentFilters.year && yearSelect.options.length > 1) {
                    yearSelect.selectedIndex = yearSelect.options.length - 1;
                    currentFilters.year = yearSelect.value;
                }
                
                // 2. Periodo por semana
                const periodTypeSelect = document.getElementById('periodTypeSelect');
                periodTypeSelect.value = 'week';
                currentFilters.periodType = 'week';
                togglePeriodFilter();
                
                // 3. Semana anterior a la actual
                const currentDate = new Date();
                const currentWeekNumber = getWeekNumber(currentDate);
                const previousWeekNumber = currentWeekNumber - 1;
                
                const weekSelect = document.getElementById('weekSelect');
                let weekFound = false;
                
                // Intentar seleccionar la semana anterior
                for (let i = 0; i < weekSelect.options.length; i++) {
                    if (weekSelect.options[i].value == previousWeekNumber) {
                        weekSelect.selectedIndex = i;
                        currentFilters.week = weekSelect.value;
                        weekFound = true;
                        break;
                    }
                }
                
                // Si no existe la semana anterior, seleccionar la √∫ltima disponible
                if (!weekFound && weekSelect.options.length > 1) {
                    weekSelect.selectedIndex = weekSelect.options.length - 1;
                    currentFilters.week = weekSelect.value;
                }
                
                applyFilters();
                
            } catch (error) {
                console.error('Error:', error);
                updateStatus('Error: ' + error.message, 'error');
            }
        }

        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
